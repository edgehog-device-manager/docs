searchData={"items":[{"type":"extras","title":"Introduction","doc":"<!---\n  Copyright 2021,2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Introduction\n\nEdgehog is an Open Source IoT platform focused on device fleet management. It conveniently handles\nfundamental operations such as performing update campaigns, getting device status information,\ngeolocation and much more. It is based on [Astarte](https://github.com/astarte-platform/astarte).\n\nThis documentation provides information on daily operations for Edgehog users and integrators. It\ngoes through fundamental operations such as performing updates, [querying APIs](tenant-graphql-api/),\nintegrating 3rd party applications, etc.","ref":"intro_user.html"},{"type":"extras","title":"Core concepts","doc":"<!---\n  Copyright 2021-2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Core concepts\n\nThis page will illustrate some of the core concepts used in Edgehog.","ref":"core_concepts.html"},{"type":"extras","title":"Hardware types, Devices and System Models - Core concepts","doc":"This section will deal with the difference between three main concepts used throughout Edgehog:\nHardware Types, Devices and System Models.\n\nTo better illustrate this, we will use as example the ACME Inc company, which manages a fleet of\ne-bikes and electric scooters. We will illustrate the hierarchy going from the bottom up, showing\nhow each concept relates to the other ones.","ref":"core_concepts.html#hardware-types-devices-and-system-models"},{"type":"extras","title":"Hardware Type - Core concepts","doc":"An Hardware Type represents the electronic hardware components embedded in an device. As an example,\na possible Hardware Type description could be \"ESP32 with a GSM module\" or \"RaspberryPi 0 with an\nLTE modem\".\n\nEach Hardware Type can have one or more Hardware Type Part Numbers associated with it. This makes\nsure that the user is able to map, e.g., a new revision of the PCB to the same Hardware Type, since\ndifferent hardware with the same Hardware Type is assumed to be compatible. Usually (but not\nnecessarily) the Hardware Type Part Number is a code that is written on the PCB.","ref":"core_concepts.html#hardware-type"},{"type":"extras","title":"Device - Core concepts","doc":"A device is an entity connected to Astarte. A Device has a uniquely identified by its Device ID, and\nit usually lives inside a product such as an e-bike (if it is not on a shelf or in a repair shop).","ref":"core_concepts.html#device"},{"type":"extras","title":"System Model - Core concepts","doc":"A System Model constitutes a group of devices implementing the same functionality for some users.\nFor example, two e-bikes can be physically identical and still belong to different System Models,\nsince they can have different software running on them.\n\nA System Model is associated with a specific Hardware Type, so two devices implementing the same\nfunctionality but using different Hardware Types will belong to two different System Models. This\nmakes it so that the System Model is the fundamental identifier when it comes to software updates.\n\nA System Model has one or more System Model Part Numbers asociated with it, allowing to track newer\nversions of a product which do not change its main functionality. Usually (but not necessarily) the\nSystem Model's Part Number is delivered along with the device, or on the box containing it.\n\nDrawing again from our bike sharing example, e-bikes and electric scooters would have two different\nSystem Models, even if they use the same Hardware Type (e.g. an ESP32 with a GSM module). It is also\npossible that the e-bikes are further split into different System Models depending on the country\nthey are deployed in if, for example, the software has to conform to speed limitations which are\nspecific for each country.","ref":"core_concepts.html#system-model"},{"type":"extras","title":"Tags, attributes and groups - Core concepts","doc":"This section will deal with various types of properties that can be added to devices to identify\nand group them.","ref":"core_concepts.html#tags-attributes-and-groups"},{"type":"extras","title":"Tags - Core concepts","doc":"Tags are string values that can be freely attached to Devices. There is no predefined semantics so\nusers are free to use them as they see fit.\n\nSome examples of tags that can be assigned to the e-bikes or electric scooters in our examples\ncould be `out-of-order`, `test_machine` or `Upgraded Brakes`.","ref":"core_concepts.html#tags"},{"type":"extras","title":"Attributes* - Core concepts","doc":"*_This feature is planned for a future release_\n\nAttributes are namespaced key-value pairs that can be attached to Devices. The namespacing happens\nby prepending the namespace to the key using a colon as separator (i.e. `namespace:key`). This\nensures that the same key in different namespaces can be addressed unambiguously.\n\nThe attribute keys are always strings, while values support all the types [supported by Astarte\nInterfaces](https://docs.astarte-platform.org/latest/030-interface.html#supported-data-types).\n\nThe majority of attributes are automatically populated using different mechanisms depending on the\nnamespaces, but there's also the possibility of manually defining custom attributes for a specific\ndevice.\n\nThe supported namespaces are:\n\n- `edgehog-synthetic`: automatically populated with values coming from Device data that is derived\n  from Edgehog (e.g. Geolocation, System Model, Hardware Type, etc...)\n- `edgehog-policy`: automatically populated with Edgehog values which are imposed on the cloud side\n  (e.g. Geolocation disabled due to GDPR restrictions).\n- `astarte-values`: automatically populated with values coming from device-owned Astarte interfaces\n  using an [Attribute Value Source](#attribute-value-source) with type `astarte-value`.\n- `astarte-attributes`: automatically populated using the `attributes` map in the Device status\n  returned from Astarte AppEngine API. Since Astarte attributes don't provide a trigger mechanism,\n  these attributes are lazily populated and should be considered eventually consistent.\n- `custom`: user-defined key-value pairs which are manually assigned to a Device.\n\nNote that all values will be converted to a string when using them as attribute values","ref":"core_concepts.html#attributes"},{"type":"extras","title":"Attribute Value Source* - Core concepts","doc":"*_This feature is planned for a future release_\n\nAn Attribute Value Source populates the attributes of a Device according to some rule.\n\nCurrently, the only supported type of Attribute Value Source is `astarte-value`, which updates\nDevice attributes using a value from an Astarte interface.","ref":"core_concepts.html#attribute-value-source"},{"type":"extras","title":"Selector - Core concepts","doc":"A Selector allows selecting a subset of Devices based on their tags and attributes. The Selector\ncan be evaluated for a Device and return `true` if the Device matches the Selector and `false`\notherwise.\n\nEach Selector can be made of one or more filters, combined using `and` and `or` and (possibly)\nparenthesized. When no parenthesis are present, `and` has a higher priority than `or` in\nexpressions.\n\n#### Supported filters\n\n##### Tag filter\n\nCreated with the syntax `\" \" in tags`, it returns `true` if `value` is included in the Device\ntags. It's also possible to use a negative filter with `\"value\" not in tags`, in this case the\nfilter will match all Devices which _don't_ have the tag.\n\n##### Attribute filter*\n\n*_Note that while Attribute filters are already supported, Attributes are going to be available in a\nfuture release_\n\nCreated with the syntax `attributes[\" : \"]    `, it returns `true` if\nthe value of the chosen attribute satisfies the expression.\n\nThe supported operators are:\n- `==` and `!=` for all value types\n- `>`, `>=`, `<`, `<=` for numeric or `datetime` values\n\n` ` can be a boolean (`true` or `false`), a string, a number (either integer or float), or one\nof the values supported using special syntax:\n\n- `now()` indicates the current datetime at the time the Selector is evaluated. This can be used to\n  do comparisons with other `datetime` attributes.\n- `datetime(\" \")` is used to pass `datetime` values in expressions. The string\n  contained in double quotes must be a valid UTC ISO8601 timestamp. Example:\n  `datetime(\"2022-06-27T16:27:40.254795Z\")`.\n- `binaryblob(\" \")` is used to pass `binaryblob` values in expressions. The\n  string contained in double quotes must be a valid Base64 encoding of the binary value. Example:\n  `binaryblob(\"Zm9vYmFy\")` to encode the string `\"foobar\"`.\n\n##### Attribute inclusion filter*\n\n*_This feature is planned for a future release_\n\n- `\" \" in attributes[\" : \"]`: returns `true` if `value` is included in the\n  chosen attribute. Note that the attribute must be an array for the expression to be valid.\n  \n#### Examples\n  \nTo provide some examples, here is a Selector to target all out of order Devices in Milan:\n\n```\n\"out-of-order\" in tags and attributes[\"edgehog-synthetic:city\"] == \"Milan\"\n```\n\nHere is a selector to target all Devices that have their service timestamp in the past so they have\nto be serviced, imagining this information is contained in the `com.foo.ServiceInfo` Astarte\ninterface in the `/serviceTimestamp`:\n\n```\nattributes[\"astarte-values:com.foo.ServiceInfo/serviceTimestamp\"] <= now()\n```\n\n#### Caveats\n\nNote that numeric values are conflated in a single numeric type, i.e. a selector with\n`attributes[\"custom:foo\"] == 42` will match either if `foo` is `integer`, `longinteger` or `double`\n(e.g it will also match `42.0`).\n\nAnother important thing to notice is that using an Attribute Filter will implicitly match only\nDevices that have that attribute. As an example, if there are 3 devices, one with attribute `foo:bar\n== 42`, the other with attribute `foo:bar == 3` and the third one with no `foo:bar` attribute, the\nAttribute Filter `attributes[\"foo:bar\"] != 42` will match the second Device but _not_ the third one,\nsince it doesn't have the target attribute.\n\nIn the future, additional syntax could be added to Selectors to allow filtering based just on the\npresence or absence of an attribute.","ref":"core_concepts.html#selector"},{"type":"extras","title":"Group - Core concepts","doc":"A Group represents a subset of devices filtered by a Selector.\n\nThe Group can be used to perform operations on Devices contained in it.\n\nSince Tags and Attributes of a Device can change, Groups do not statically define the set of Devices\nthey contain but they change dynamically following Device changes.\n\nNote that a Device can't be manually assigned to a Group, its tags and attributes must be\nused to make it satisfy the group Selector.","ref":"core_concepts.html#group"},{"type":"extras","title":"Hardware Types","doc":"<!---\n  Copyright 2021,2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Hardware Types\n\nFor each hardware type the following information can be displayed and edited.\n\n* Name: a user friendly name, such as \"Strawberry Pi 5\"\n* Handle: a machine friendly identifier, such as \"strawberry-pi-5\" (it must be a lower case, alpha\nnumeric string, with no spaces and dashes allowed in the middle)\n* Part Numbers: a list of part numbers, such as \"STBEPI-5-MA-2GB-REV1\",\"STBEPI-5-MB-8GB-REV1\",\n\"STBEPI-5-MB-8GB-REV2\", etc... Multiple part numbers can be entered using the \"Add Part Number\"\nbutton.\n\n![Hardware Types Screenshot](assets/hardware_types.png)","ref":"hardware_types.html"},{"type":"extras","title":"Create Hardware Type - Hardware Types","doc":"This page allows creating a new hardware type, once created it can be edited at a later time.\n\n![Create Hardware Type Screenshot](assets/create_hardware_type.png)","ref":"hardware_types.html#create-hardware-type"},{"type":"extras","title":"Update Hardware Type - Hardware Types","doc":"By clicking the link on the hardware type list it is possible to open the detailed Hardware Type\npage. It is possible to edit the existing hardware type and to update it clicking the \"Update\"\nbutton.","ref":"hardware_types.html#update-hardware-type"},{"type":"extras","title":"System Models","doc":"<!---\n  Copyright 2021,2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# System Models\n\nAs already mentioned in the [Core concepts](core_concepts.html), System Model represent a group of\ndevices providing the same functionalities to users.\n\nIn Edgehog a System Model has this information associated with it:\n\n- Name: a user friendly name used to identify the System Model (e.g. \"E-Bike v2\")\n- Handle: a machine friendly identifier for the System Model (e.g. \"e-bike-v2\"). A valid handle must\n  begin with a lowercase letter followed by any number of lower case letters, numbers or dashes\n  (`-`).\n- Hardware type: the [Hardware Type](core_concepts.html#hardware-type) that is used for this system model. \n  Each System Model is associated with exactly one Hardware Type.\n- Part numbers: the Part Numbers for this System Model. Each System Model can have one or more Part\n  Numbers associated with it, and Devices will be associated with a System Model based on the Part\n  Number they declare to implement.\n- Picture: each System Model can have a picture associated with it, so that Devices using that\n  System Model can be identified at a glance.\n\nThe following sections will illustrate all the pages that can be used to list, create and edit\nSystem Models.","ref":"system_models.html"},{"type":"extras","title":"System Model List - System Models","doc":"![System Model List Screenshot](assets/system_models.png)\n\nIn the system model list you can see all the System Models that are available. All information\nrelative to each System Model (minus the picture) is present in the table, and clicking on the name\nbrings to the [System Model](#system-model) page.\n\nClicking on the \"Create System Model\" button in the top right brings to\n[Create System Model](#create-system-model) page.","ref":"system_models.html#system-model-list"},{"type":"extras","title":"System Model - System Models","doc":"![System Model Page Screenshot](assets/system_model.png)\n\nThe System Model page shows the information about a specific System Model and allows updating all of\nthem except the Hardware Type.\n\nEditing any field and then pressing the \"Update\" button saves the new values for the System Model.\nThe \"Add Part Number\" button allows adding additional Part Numbers to a System Model, and the thrash\nicon on the right of each of them allows deleting them.","ref":"system_models.html#system-model"},{"type":"extras","title":"Create System Model - System Models","doc":"![Create System Model Screenshot](assets/create_system_model.png)\n\nThe Create System Model page allows creating a new System Model.\n\nThe System Model information can be provided using the form, and pressing the \"Update\" button saves\nthe System Model. The Hardware Type must be chosen from a list of available Hardware Types using the\ndropdown menu. The \"Add Part Number\" button allows adding additional Part Numbers for the System\nModel.","ref":"system_models.html#create-system-model"},{"type":"extras","title":"Devices","doc":"<!---\n  Copyright 2021-2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Devices\n\nAs mentioned in the [core concepts](core_concepts.html), a Device is an entity connected to Astarte.\n\nIn the device list you can see all the Devices that are available.\n\n![Devices Screenshot](assets/devices.png)\n\nFor each Device the following information can be displayed:\n\n- Name: a user friendly name\n- Device ID: the ID that uniquely identifies the device connecting to Astarte\n- System Model: the System Model associated to the Device\n- Hardware Type: the Hardware Type associated to the Device's System Model\n- Status: Reports the connection status, indicating whether the Device is connected to Astarte\n- Last Seen: Reports the time of the last connection activity of the Device\n\nClicking on a Device's name brings to a page dedicated to that Device to display additional info.","ref":"devices.html"},{"type":"extras","title":"Adding a Device - Devices","doc":"Each Device will become visible in Edgehog automatically the first time it connects to Astarte.\nIndeed, Astarte informs Edgehog about the Device's presence and activity via Astarte Triggers, which\nshould be configured to relay the appropriate events.","ref":"devices.html#adding-a-device"},{"type":"extras","title":"Associating a Device to a System Model - Devices","doc":"Each Device is associated to a specific System Model. The System Model is the fundamental identifier\nwhen it comes to software updates, since it dictates which software is supported and what\nfunctionalities should be configured.\n\nHowever, during its lifetime, a Device can be tied to different System Models. Say, for example,\nthat two different models of e-bikes are sent to maintenance; if they share the same hardware, the\nworking PCB board of one model could be fitted into the other one.\n\nFor this reason, each time a Device connects to Astarte, it can notify Astarte about the System\nModel it refers to, exposing its Part Number. Astarte then informs Edgehog via Astarte Triggers, so\nthat Edgehog can associate the Device to the correct System Model by matching the Device's Part\nNumber with the ones of the System Model.","ref":"devices.html#associating-a-device-to-a-system-model"},{"type":"extras","title":"Tags and Attributes - Devices","doc":"A Device can have some [Tags and Attributes](core_concepts.html#tags-attributes-and-groups)\nassociated with it.\n\nTags are purely user-defined and can be added and removed from the Device page.\n\nAttributes are mostly automatically populated but the `custom` namespace attributes can be assigned\nfreely from the Device page.\n\nTags and attributes can be used to determine the membership of a Device to a specific\n[group](groups.html), which in turn can be used to assign a Device to a specific Update Channel when\nreceiving [OTA Updates](ota_updates.html).","ref":"devices.html#tags-and-attributes"},{"type":"extras","title":"Device info - Devices","doc":"On the page of each Device different sets of data are shown. On top of the basic info already\nvisible in the device list, additional sections can be displayed here to report operational data\nexposed by the device.\n\nThe details about how devices publish such data are explained in\n[Interacting with Edgehog](interacting_with_edgehog.html).","ref":"devices.html#device-info"},{"type":"extras","title":"Hardware info - Devices","doc":"This section reports an overview on the general hardware capabilities of the Device.\n\n![Device Hardware Info Screenshot](assets/device_hardware_info.png)","ref":"devices.html#hardware-info"},{"type":"extras","title":"Operating System - Devices","doc":"This section reports an overview of the operating system of the Device.\n\n![Device Operating System Screenshot](assets/device_operating_system.png)","ref":"devices.html#operating-system"},{"type":"extras","title":"Runtime - Devices","doc":"This section reports an overview about the Edgehog runtime running on the Device.\n\n![Device Runtime Screenshot](assets/device_runtime.png)","ref":"devices.html#runtime"},{"type":"extras","title":"Base Image - Devices","doc":"This section reports an overview of the Base Image of the Device.\n\n![Device Base Image Screenshot](assets/device_base_image.png)","ref":"devices.html#base-image"},{"type":"extras","title":"System status - Devices","doc":"This section reports an overview on the current system status of the Device.\n\n![Device System Status Screenshot](assets/device_system_status.png)","ref":"devices.html#system-status"},{"type":"extras","title":"Storage Status - Devices","doc":"This section reports an overview on the capacity and usage of the storage units of the Device.\n\n![Device Storage Screenshot](assets/device_storage.png)","ref":"devices.html#storage-status"},{"type":"extras","title":"Battery status - Devices","doc":"This section reports an overview on the current status of the battery slots of the Device.\n\n![Device Battery Screenshot](assets/device_battery.png)","ref":"devices.html#battery-status"},{"type":"extras","title":"Cellular Connection - Devices","doc":"This section reports an overview of the cellular connection of the Device.\n\n![Device Cellular Connection Screenshot](assets/device_cellular_connection.png)","ref":"devices.html#cellular-connection"},{"type":"extras","title":"Network Interfaces - Devices","doc":"This section reports the list of network interfaces of the Device.\n![Device Network Interfaces Screenshot](assets/device_network_interfaces.png)","ref":"devices.html#network-interfaces"},{"type":"extras","title":"Nearby WiFi APs - Devices","doc":"This section reports the list of nearby Access Points that the Device found while scanning for WiFi\nsignals.\n\n![Device WiFi APs Screenshot](assets/device_wifi_aps.png)","ref":"devices.html#nearby-wifi-aps"},{"type":"extras","title":"Geolocation - Devices","doc":"This section reports the approximate location of the Device, using Edgehog's geolocation modules to\nestimate a set of GPS coordinates.\n\n![Device Geolocation Screenshot](assets/device_geolocation.png)\n\nDepending on the data exposed by the Device, the coordinates can be estimated from:\n\n- the GPS position published via the Astarte interface\n  [io.edgehog.devicemanager.Geolocation](astarte_interfaces.html).\n- nearby WiFi APs that the Device detected recently, published via the Astarte interface\n  [io.edgehog.devicemanager.WiFiScanResults](astarte_interfaces.html)\n- the IP address used by the Device to connect to Astarte\n\nBased on the available data, Edgehog's geolocation modules try to find to best estimate by relying\non the most up-to-date info and using the ones that provide the most accuracy.","ref":"devices.html#geolocation"},{"type":"extras","title":"SDKs & Runtime","doc":"<!---\n  Copyright 2021,2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# SDKs & Runtime","ref":"device_sdks_runtime.html"},{"type":"extras","title":"Edgehog Device ESP32 SDK - SDKs & Runtime","doc":"Edgehog Device ESP32 is an [ESP-IDF component](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/index.html)\nwritten in C, that enables remote device management using Edgehog.\n* [edgehog-esp32-device](https://github.com/edgehog-device-manager/edgehog-esp32-device)\n* [documentation](device-sdks/esp32/index.html)","ref":"device_sdks_runtime.html#edgehog-device-esp32-sdk"},{"type":"extras","title":"Edgehog Device Runtime - SDKs & Runtime","doc":"Edgehog Device Runtime is a portable middleware written in Rust, that enables remote device management using Edgehog.\n* [edgehog-device-runtime](https://github.com/edgehog-device-manager/edgehog-device-runtime)","ref":"device_sdks_runtime.html#edgehog-device-runtime"},{"type":"extras","title":"Attribute Value Sources","doc":"<!---\n  Copyright 2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Attribute Value Sources\n\nDevice attributes can be populated using external sources using Attribute Value Sources. These\nprovide mechanisms to automatically update some device attributes according to some rules.\n\nAll the concepts used below are detailed in the [Core\nConcepts](core_concepts.html#tags-attributes-and-groups) page, this guide is oriented towards\noperational details to use Attribute Value Sources.","ref":"attribute_value_sources.html"},{"type":"extras","title":"Populating attributes using Astarte values - Attribute Value Sources","doc":"To populate an attribute using a value coming from an Astarte interface, an Attribute Value Source\nof type `astarte-value` must be added. This will populate an attribute whose value will be\neventually consistent with the value of the target Astarte interface and path.\n\nWhen creating an `astarte-value` Attribute Value Source, the following information must be provided:\n\n- Interface: the target interface to be used\n- Major version: the target major version of the interface\n- Path: the target path containing the value that will be used as attribute value\n\nAfter its creation, the Attribute Value Source will install an Astarte trigger, so when the target\ninterface value changes, the change will be (eventually) reflected in the Attribute value. The\nAttribute key will be `astarte-value:  `. The value will also be initialized\nasynchronously for all devices by querying AppEngine API in a background task.","ref":"attribute_value_sources.html#populating-attributes-using-astarte-values"},{"type":"extras","title":"Groups","doc":"<!---\n  Copyright 2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Groups\n\nEdgehog allows creating groups of Devices based on tags and attributes. This makes it easy to target\nthem with fleet operations.\n\nAll the concepts used below are detailed in the [Core\nConcepts](core_concepts.html#tags-attributes-and-groups) page, this guide is oriented towards\noperational details to create a group.","ref":"groups.html"},{"type":"extras","title":"Creating a group - Groups","doc":"A new group can be created from the Groups section of Edgehog.\n\nWhen creating a group, the following information must be provided:\n\n- Name: the display name of the group\n- Handle: an handle matching the `^[a-z][a-z\\d\\-]*$` regular expression.\n- Selector: a [Selector](core_concepts.html#selector) that will determine which Devices belong to\n  this group (i.e. all Devices that match the Selector)","ref":"groups.html#creating-a-group"},{"type":"extras","title":"Deleting a group - Groups","doc":"To delete a group, just press the Delete icon next to it in the group list.\n\nNote that deleting a group means that all automatic operations based on that group (e.g. Update\nChannel auto-assignment) will cease to work.","ref":"groups.html#deleting-a-group"},{"type":"extras","title":"Batch Operations*","doc":"<!---\n  Copyright 2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Batch Operations*\n\n*_This feature is planned for a future release_\n\nEdgehog provides facilities to perform batch operations on groups of devices. These are used to\navoid having to perform repetitive tasks on many devices.\n\nThis guide presents the batch operations which can be performed using Edgehog.","ref":"batch_operations.html"},{"type":"extras","title":"Maintenance Window Setting - Batch Operations*","doc":"Using the Edgehog API or its frontend, it is possible to set the same [Maintenance\nWindow](core_concepts.html#maintenance-window) to all devices belonging to a Group.\n\nWhen performing the operation, the following information must be provided\n\n- Maintenance Window Start: the UTC timestamp that marks the beginning of the Maintenance Window\n- Maintenance Window End: the UTC timestamp that marks the end of the Maintenance Window\n- Group: the name of the target group\n\nAll devices belonging to the Group when the operation is started will be assigned the new\nMaintenance Window. Note that the Maintenance Window remains a property of the single device and the\nassignment is performed one-shot when the operation is performed (i.e. Devices that become member of\nthe group later are not affected by it).","ref":"batch_operations.html#maintenance-window-setting"},{"type":"extras","title":"OTA Update concepts","doc":"<!---\n  Copyright 2021-2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# OTA Update concepts\n\nThis page will illustrate some of the OTA Update concepts used in Edgehog.","ref":"ota_update_concepts.html"},{"type":"extras","title":"Base Image - OTA Update concepts","doc":"A Base Image is an image created to be run on a Device. The exact content of the Base Image can vary\ndepending on the use case, but it usually contains the operating system image or the device\nfirmware. Each Base Image belongs to a [Base Image Collection](#base-image-collection).\n\nBase Images follow semantic versioning, so that the user is able to know when a specific update can\ncontain breaking changes. Each Base Image must have a unique version number.","ref":"ota_update_concepts.html#base-image"},{"type":"extras","title":"Base Image Collection - OTA Update concepts","doc":"A Base Image Collection is a set of Base Images associated with a specific [System\nModel](core_concepts.html#system-model) and, implicitly via the System Model, with a specific [Hardware\nType](core_concepts.html#hardware-type). The mapping relation between Base Image Collection and System Models is 1:1,\nso a Base Image Collection is associated with a single System Model and viceversa.\n\nA Base Image Collection contains all the Base Images that ran, are running or could be run on a\nSystem Model. Drawing from the bike sharing example, there would be a different Base Image\nCollection for, e.g., e-bikes from each specific country to handle the different speed limitations.\n\nThe primary purpose of a Base Image Collection is to limit what can be installed to a System Model,\npreventing unintended installations, such as electric scooter firmware on an e-bike.","ref":"ota_update_concepts.html#base-image-collection"},{"type":"extras","title":"Version Requirement - OTA Update concepts","doc":"A Version Requirement specifies compatibility between versions. It is expressed as a string containing\nvarious criteria and adheres to syntax detailed in\n[Elixir's Version.Requirement](https://hexdocs.pm/elixir/Version.html#module-requirements).\nFor example, when the Version Requirement `>= 2.0.0 and < 3.0.0` is used to define the\n`Supported starting versions` of Base Image `foo`, it identifies a subset of Base Images\nwithin the same Base Image Collection that can be updated to the Base Image `foo`.","ref":"ota_update_concepts.html#version-requirement"},{"type":"extras","title":"Update Channel - OTA Update concepts","doc":"An Update Channel represents the subscription of a Device to a specific set of Base Images.\nTo assign a Device to a specific Update Channel (other than the default one) the device must\nbelong to a [Group](core_concepts.html#group) and that Group has to be assigned to the Target Groups of the Update\nChannel.\n\nThe same Base Image can be associated with multiple Update Channels. This guarantees\nthat once testers in the `beta` Update Channel validate the Base Image, the exact same Base Image\nwill be used to update devices in the `default` Update Channel.","ref":"ota_update_concepts.html#update-channel"},{"type":"extras","title":"Update Campaign - OTA Update concepts","doc":"An Update Campaign is the operation that tracks the distribution of a specific Base Image to all\ndevices belonging to an Update Channel.\n\nAn Update Campaign can define additional constraints about which devices can be updated (e.g.\nminimum current version, force downgrade, etc).","ref":"ota_update_concepts.html#update-campaign"},{"type":"extras","title":"Rollout Mechanism - OTA Update concepts","doc":"The Rollout Mechanism determines the details of how an Update Campaign is carried out.\n\nIt is responsible of deciding if the update is pushed towards the devices or pulled by users\ninteracting with them.\n\nIt also defines other details like how many devices are updated at a time, how many errors should be\nsupported before aborting the campaign etc.\n\nThere are currently two main Mechanisms available: Push and Optional*. The Push mechanism pushes the\nupdate towards the device unconditionally, while the Optional mechanism waits for a confirmation on\nthe Device side (usually given by a user) before starting to download the update.\n\n*_The Optional rollout mechanism is planned for a future release_","ref":"ota_update_concepts.html#rollout-mechanism"},{"type":"extras","title":"OTA Operation - OTA Update concepts","doc":"An OTA Operation tracks the progress of an update to a specific Device. It is started when Edgehog\nstarts pushing the update to the Device and ends either with a success or with an error (possibly\ndue to a timeout).","ref":"ota_update_concepts.html#ota-operation"},{"type":"extras","title":"Update Target - OTA Update concepts","doc":"An Update Target is the target of an Update Campaign, which is composed by the targeted device, \nthe status of the target in the linked Update Campaign, OTA Operation and additional metadata.","ref":"ota_update_concepts.html#update-target"},{"type":"extras","title":"Maintenance Window* - OTA Update concepts","doc":"*_This feature is planned for a future release_\n\nEach Device can have an optional Maintenance Window. This is used by Update Campaign to determine\nwhich Devices can be updated at a specific time.\n\nIf a Device declares a Maintenance Window, the updates targeting it will start only in the interval\ndefined by it. Note that there's no guarantee that the update will also terminate inside the\nMaintenance Window.","ref":"ota_update_concepts.html#maintenance-window"},{"type":"extras","title":"Base Images","doc":"<!---\n  Copyright 2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Base Images\n\nAs mentioned in the [OTA Update concepts](ota_update_concepts.html), Base Image is an image created\nto be run on a Device. The exact content of the Base Image can vary depending on the use case,\nbut it usually contains the operating system image or the device firmware. Each Base Image belongs to\na [Base Image Collection](ota_update_concepts.html#base-image-collection).\n\nBase Images follow semantic versioning, so that the user is able to know when a specific update can\ncontain breaking changes. Each Base Image must have a unique version number.\n\nIn Edgehog a Base Image has this information associated with it:\n\n- Base Image Collection: the Base Image Collection that is associated with this Base Image.\n- Base Image URL: link to a file with the Base Image content.\n- Version: a version number following the [Semantic Versioning](https://semver.org) spec. The\n  version number must be unique.\n- Supported starting versions (optional): a [Version Requirement](ota_update_concepts.html#version-requirement)\n  that the Device must satisfy with its current Base Image to be updated with this Base Image.\n  If a Device that does not satisfy the requirement is included in an Update Campaign\n  that uses this Base Image, the result of the [OTA Operation](ota_update_concepts.html#ota-operation) is an error.\n- Release Display Name (optional): a localized user-friendly name for the release.\n- Description (optional): a localized description of the content of the Base Image.\n\nThe following sections will illustrate all the pages that can be used to list, create, edit and delete\nBase Images.","ref":"base_images.html"},{"type":"extras","title":"Base Image List - Base Images","doc":"![Base Image List Screenshot](assets/base_image_list.png)\n\nThe Base Image Collection page shows table with associated Base Images.\nClicking on the Base Image Version brings to the [Base Image](#base-image) page.\nClicking on the \"Create Base Image\" button in the right brings to the [Create Base Image](#create-base-image) page.","ref":"base_images.html#base-image-list"},{"type":"extras","title":"Base Image - Base Images","doc":"![Base Image Page Screenshot](assets/base_image.png)\n\nThe Base Image page shows the information about a specific Base Image and allows updating some of them.\n\nEditing any field and then pressing the \"Update\" button saves the new values for the Base Image.\nThe \"Delete\" button allows to delete the Base Image.","ref":"base_images.html#base-image"},{"type":"extras","title":"Create Base Image - Base Images","doc":"![Create Base Image Screenshot](assets/base_image_create.png)\n\nThe Create Base Image page allows creating a new Base Image.\n\nThe Base Image information can be provided using the form, and pressing the \"Create\" button saves the Base Image.\n\nSome information can be automatically filled in if the Base Image can be parsed by one of the\n[supported Base Image parsers](#supported-base-image-parsers). Other than that, users are free to\nuse whatever format they choose for the artifact that will be pushed towards the device, provided\nthe Device is able to handle it.\n\nWhen you upload add Base Image in a Base Image Collection, no update is pushed towards devices,\nthe Base Image is just uploaded in Edgehog's storage. To start pushing updates towards devices, an\n[Update Campaign](ota_update_concepts.html#update-campaign) must be created.","ref":"base_images.html#create-base-image"},{"type":"extras","title":"Supported Base Image parsers - Base Images","doc":"Base Image parsers are not implemented yet. As soon as they are implemented, this section will be\npopulated with the supported formats.","ref":"base_images.html#supported-base-image-parsers"},{"type":"extras","title":"Base Image Collections","doc":"<!---\n  Copyright 2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Base Image Collections\n\nAs mentioned in the [OTA Update concepts](ota_update_concepts.html), Base Image Collection represent\na set of Base Images associated with a specific [System Model](core_concepts.html#system-model) and,\nimplicitly via the System Model, with a specific [Hardware Type](core_concepts.html#hardware-types).\nThe mapping relation between Base Image Collection and System Models is 1:1, so a Base Image Collection\nis associated with a single System Model and viceversa.\n\nA Base Image Collection contains all the Base Images that ran, are running or could be run on a\nSystem Model. Drawing from the bike sharing example, there would be a different Base Image\nCollection for, e.g., e-bikes from each specific country to handle the different speed limitations.\n\nThe primary purpose of a Base Image Collection is to limit what can be installed to a System Model,\npreventing unintended installations, such as electric scooter firmware on an e-bike.\n\nIn Edgehog a Base Image Collection has this information associated with it:\n\n- Name: a user friendly name used to identify the Base Image Collection (e.g. \"E-Scooter OS\")\n- Handle: a machine friendly identifier for the Base Image Collection (e.g. \"e-scooter-os\"). A valid handle\n  must begin with a lowercase letter followed by any number of lower case letters, numbers or dashes (`-`).\n- System Model: the System Model that is associated with this Base Image Collection.\n- Base Images: a set of Base Images associated with this Base Image Collection.\n\nThe following sections will illustrate all the pages that can be used to list, create, edit and delete\nBase Image Collections.","ref":"base_image_collections.html"},{"type":"extras","title":"Base Image Collection List - Base Image Collections","doc":"![Base Image Collection List Screenshot](assets/base_image_collection_list.png)\n\nIn the base image collection list you can see the table with all Base Image Collections that are available.\nClicking on the name brings to the [Base Image Collection](#base-image-collection) page.\n\nClicking on the \"Create Base Image Collection\" button in the top right brings to\n[Create Base Image Collection](#create-base-image-collection) page.","ref":"base_image_collections.html#base-image-collection-list"},{"type":"extras","title":"Base Image Collection - Base Image Collections","doc":"![Base Image Collection Page Screenshot](assets/base_image_collection.png)\n\nThe Base Image Collection page shows the information about a specific Base Image Collection and Base Images\nassociated with it in table below.\n\nEditing any field and then pressing the \"Update\" button saves the new values for the Base Image Collection.\nThe \"Create Base Image\" button allows adding additional Base Images to the Base Image Collection.\nClicking on the Base Image Version brings to the Base Image page.\nThe \"Delete\" button allows to delete the Base Image Collection.","ref":"base_image_collections.html#base-image-collection"},{"type":"extras","title":"Create Base Image Collection - Base Image Collections","doc":"![Create Base Image Collection Screenshot](assets/base_image_collection_create.png)\n\nThe Create Base Image Collection page allows creating a new Base Image Collection.\n\nThe Base Image Collection information can be provided using the form, and pressing the \"Create\" button saves\nthe Base Image Collection. The System Model must be chosen from a list of available System Models using the\ndropdown menu.","ref":"base_image_collections.html#create-base-image-collection"},{"type":"extras","title":"Update Channels","doc":"<!---\n  Copyright 2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Update Channels\n\nAs mentioned in the [OTA Update concepts](ota_update_concepts.html), Update Channel represents the subscription\nof a Device to a specific set of Base Images.\n\nTo assign a Device to a specific Update Channel the device must belong to a [Group](core_concepts.html#group)\nand that Group has to be assigned to the Target Groups of the Update Channel.\n\nThe same Base Image can be associated with multiple Update Channels. This guarantees\nthat once testers in the `beta` Update Channel validate the Base Image, the exact same Base Image\nwill be used to update devices in the `default` Update Channel.\n\nIn Edgehog an Update Channels has this information associated with it:\n\n- Name: a user friendly name used to identify the Update Channel (e.g. \"Beta\").\n- Handle: a machine friendly identifier for the Update Channels (e.g. \"beta\"). A valid handle\n  must begin with a lowercase letter followed by any number of lower case letters, numbers or dashes (`-`).\n- Target Groups: a list of [groups](groups.html) containing Devices which will\n  automatically get assigned to this Update Channel.\n\nA group can be associated only with a single Update Channel. To change the auto-assignment of a\nspecific group from an Update Channel to another, the group must be removed from the previous Update\nChannel and then added to the new one.\n\nThe following sections will illustrate all the pages that can be used to list, create, edit and delete\nUpdate Channels.","ref":"update_channels.html"},{"type":"extras","title":"Update Channel List - Update Channels","doc":"![Update Channel List Screenshot](assets/update_channel_list.png)\n\nIn the Update Channel list you can see the table with all Update Channels that are available.\nClicking on the name brings to the [Update Channel](#update-channel) page.\n\nClicking on the \"Create Update Channel\" button in the top right brings to\n[Create Update Channel](#create-update-channel) page.","ref":"update_channels.html#update-channel-list"},{"type":"extras","title":"Update Channel - Update Channels","doc":"![Update Channel Page Screenshot](assets/update_channel.png)\n\nThe Update Channel page shows and allows updating the information about a specific Update Channel.\n\nEditing any field and then pressing the \"Update\" button saves the new values for the Update Channel.\nThe \"Delete\" button allows to delete the Update Channel.","ref":"update_channels.html#update-channel"},{"type":"extras","title":"Create Update Channel - Update Channels","doc":"![Create Update Channel Screenshot](assets/update_channel_create.png)\n\nThe Create Update Channel page allows creating a new Update Channel.\n\nThe Update Channel information can be provided using the form, and pressing the \"Create\" button saves\nthe Update Channel. Target Group(s) must be chosen from a list of available Groups using the dropdown menu.","ref":"update_channels.html#create-update-channel"},{"type":"extras","title":"Update Campaigns","doc":"<!---\n  Copyright 2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Update Campaigns\n\nAs mentioned in the [OTA Update concepts](ota_update_concepts.html), Update Campaign is the operation\nthat tracks the distribution of a specific [Base Image](ota_update_concepts.html#base-image) to all devices\nbelonging to an [Update Channel](ota_update_concepts.html#update-channel).\n\nNote that an Update Campaign can only send updates for the same\n[Base Image Collection](ota_update_concepts.html#base-image-collection), and special operations\n(like converting a Device from a one System Model to another) must always be done with a [Manual OTA\nUpdate](ota_updates.html#manual-ota-updates).\n\nThe following sections will illustrate all the pages that can be used to list, create and view Update Campaigns.","ref":"update_campaigns.html"},{"type":"extras","title":"Update Campaign List - Update Campaigns","doc":"![Update Campaign List Screenshot](assets/update_campaign_list.png)\n\nIn the Update Campaign list you can see the table with all Update Campaigns. Clicking on the name brings\nto the [Update Campaign](#update-campaign) page.\n\nClicking on the \"Create Update Campaign\" button in the top right brings to\n[Create Update Campaign](#create-update-campaign) page.","ref":"update_campaigns.html#update-campaign-list"},{"type":"extras","title":"Create Update Campaign - Update Campaigns","doc":"![Create Update Campaign Screenshot](assets/update_campaign_create.png)\n\nThe Create Update Campaign page allows creating a new Update Campaign.\n\nWhen creating an Update Campaign, the following information must be provided\n\n- Base Image: the target Base Image for the Update Campaign.\n- Update Channel: the target Update Channel for the Update Campaign.\n- [Roll-out Mechanism](#roll-out-mechanism) properties.\n\nThe Update Campaign information can be provided using the form, and pressing the \"Create\" button saves\nthe Update Campaign.\n\nOnce created, the Update Campaign will start rolling out updates towards the devices, and its\nprogress can be checked from the Edgehog Dashboard or through Edgehog GraphQL API.\n\nNote that the campaign will \"snapshot\" the Devices belonging to the Update Channel when it's\nstarted, and will target only those. If additional Devices are added to the Update Channel (either\nmanually or automatically via auto-assignment) _after_ the Update Campaign is created, they won't\nreceive the Base Image and will require a separate campaign to be started.\n\nOnly a single Update Campaign can be started for a given System Model and Update Channel\ncombination, so creating a new Update Campaign while another one is already running will implicitly\ncancel* the old one. This means that Devices that didn't yet receive the Base Image of the old Update\nCampaign will directly receive the new one, without any intermediate step.\n\n*_Implicit Cancellation feature is planned for a future release_","ref":"update_campaigns.html#create-update-campaign"},{"type":"extras","title":"Roll-out mechanism - Update Campaigns","doc":"Here are the currently supported Roll-out Mechanisms and their properties\n\n##### `push`\n\nThis Roll-out mechanism pushes the update towards the device unconditionally. This can be used to\nprovide automatic updates where the user should not have the choice of refusing the update.\n\nThe properties of this Roll-out Mechanism are:\n\n- Max Pending Operations: the maximum number of pending [OTA Operations](ota_update_concepts.html#ota-operation).\n  The Update Campaign will have at most this number of OTA Operations that are started \n  but not yet finished (either successfully or not).\n- Max Failures: the maximum percentage of failures allowed over the number of total targets. If the failures \n  exceed this threshold, the Update Campaign terminates with a failure.\n- Request Retries: the number of times an update must be retried on a specific Device before considering it\n  a failure. Note that the update is retried only if the OTA Request doesn't get acknowledged from the device.\n- Request Timeout: the timeout (in seconds) to wait before considering an OTA Request lost (and possibly retry).\n- Force Downgrade (optional): when checked forces downgrading a Device which is currently using a later version\n  of the Base Image.\n\n##### `optional`*\n\n*_The Optional rollout mechanism is planned for a future release_\n\nThis Roll-out mechanism just pushes a message towards the Device informing that an update is\navailable. The update is downloaded to the device only after the user accepts the update. The update\nis not required to be pushed immediately, to provide a backpressure mechanism if many users accept\nthe update at the same time.","ref":"update_campaigns.html#roll-out-mechanism"},{"type":"extras","title":"Update Campaign - Update Campaigns","doc":"![Update Campaign Page Screenshot](assets/update_campaign.png)\n\nThe Update Campaign page shows the information about a specific Update Campaign and Devices associated \nwith it in table below.\n\nClicking on the Base Image Collection, Base Image, Update Channel or Device name bring to the corresponding page.","ref":"update_campaigns.html#update-campaign"},{"type":"extras","title":"OTA Updates","doc":"<!---\n  Copyright 2022-2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# OTA Updates\n\nEdgehog provides an OTA update mechanism that allows remotely updating devices. The OTA update\nmechanism is not tied to a specific platform and can be used on any [Edgehog\nruntime](device_sdks_runtime.html) which implements the\n[`io.edgehog.devicemanager.OTARequest`](astarte_interfaces.html#io-edgehog-devicemanager-otarequest-v1-0),\n[`io.edgehog.devicemanager.OTAEvent`](astarte_interfaces.html#io-edgehog-devicemanager-otaevent-v0-1)\nand\n[`io.edgehog.devicemanager.BaseImage`](astarte_interfaces.html#io-edgehog-devicemanager-baseimage-v0-1)\ninterfaces.\n\nOTA Update concepts are detailed in the [dedicated page](ota_update_concepts.html), this guide \ndemonstrates the usage of an OTA update mechanism.","ref":"ota_updates.html"},{"type":"extras","title":"Managed OTA Updates - OTA Updates","doc":"Edgehog provides a mechanism to roll-out OTA updates to devices automatically, based on their [System\nModel](core_concepts.html#system-model) and their membership to specific [Groups](core_concepts.html#group).\n\nTo push updates towards Devices, an Update Campaign must be created. It's important to note that an Update\nCampaign can only send updates for the same Base Image Collection. Special operations, such as \nconverting a Device from one System Model to another, must always be done with a [Manual OTA\nUpdate](#manual-ota-updates).\n\nOnce created, the Update Campaign will start rolling out updates towards the devices, and its\nprogress can be checked from the Edgehog Dashboard or through Edgehog GraphQL API.\n\nNote that the campaign will \"snapshot\" the Devices belonging to the Update Channel when it's\nstarted, and will [target](ota_update_concepts.html#update-target) only those.\n\nOnce started, the Update Campaign waits for device to come online, at which point it initiates the OTA Update.\n[Roll-out mechanim](update_campaigns.html#roll-out-mechanism) properties can affect this process.\nFor example, `Max Pending Operations` setting may postpone some OTA Operations.\n\nBefore actual push to the Device corresponding [Update Target](ota_update_concepts.html#update-target)\nis verified for fulfillment of Base Image and Roll-out mechanism criteria. For example:\n- Devices having same Base Image version will be silently marked as successful.\n- Devices with Base Images that don't meet [Version Requirement](ota_update_concepts.html#version-requirement)\n  of distributed Base Image will be marked as failed, unless the `Force Downgrade` option \n  of [Push Roll-out mechanism](update_campaigns.html#roll-out-mechanism) is enabled.","ref":"ota_updates.html#managed-ota-updates"},{"type":"extras","title":"Manual OTA Updates - OTA Updates","doc":"As an escape hatch, it's always possible to manually update a [Device](core_concepts.html#device)\nfrom its page on the Edgehog dashboard (or using the Edgehog GraphQL API).\n\nNote that Manual OTA Updates do not perform any check on the [System Model](core_concepts.html#system-model),\nso they can effectively be used to change the System Model of a Device. This also means that the user \nmust exercise particular attention to avoid bricking a Device, if the Device does not implement the necessary\nsafety checks.\n\n![Manual OTA Update Screenshot](assets/manual_ota_update.png)","ref":"ota_updates.html#manual-ota-updates"},{"type":"extras","title":"Architecture overview","doc":"<!---\n  Copyright 2021,2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Architecture overview\n\nThis is an overview of Edgehog's architecture.\n\n![Edgehog Architecture](assets/edgehog_architecture.png)\n\nThe following sections will detail the interactions between Edgehog and the other components\nrepresented in the architecture diagram.","ref":"overview.html"},{"type":"extras","title":"User interaction - Architecture overview","doc":"Edgehog exposes two ways to interact with it: a frontend that can be used by users and a GraphQL\nAPI which can be used by third party applications to programmatically perform all actions that can\nbe performed in the frontend. As a matter of fact, the frontend itself uses the GraphQL API to\nperform its tasks.","ref":"overview.html#user-interaction"},{"type":"extras","title":"Database interaction - Architecture overview","doc":"Edgehog uses PostgreSQL to store its data. The database schema supports multiple tenants which are\nisolated at the database level. This makes it possible to use a single Edgehog instance with\nmultiple tenants (e.g. in a SaaS scenario).","ref":"overview.html#database-interaction"},{"type":"extras","title":"Device interaction (through Astarte) - Architecture overview","doc":"To interact with the other side of the domain (i.e. devices), Edgehog is built upon\n[Astarte](https://github.com/astarte-platform/astarte) and it exchanges data with it using two of\nits mechanisms: its [REST API](https://docs.astarte-platform.org/latest/api/index.html) and [Astarte\nTriggers](https://docs.astarte-platform.org/latest/060-triggers.html). Each Edgehog tenant is mapped\nto an Astarte Realm, and it owns the credentials to interact with all the Realm APIs for that\nspecific Realm.","ref":"overview.html#device-interaction-through-astarte"},{"type":"extras","title":"Edgehog Astarte Interfaces - Architecture overview","doc":"The interaction between Edgehog and Astarte is defined by a [set of\ninterfaces](https://github.com/edgehog-device-manager/edgehog-astarte-interfaces) that define which\ndata is sent both from Edgehog to the Devices and from the Devices towards Edgehog. Additionally,\nconnection and disconnection triggers ar installed in the Astarte Realm, and point to the triggers\nendpoint of the Edgehog tenant.","ref":"overview.html#edgehog-astarte-interfaces"},{"type":"extras","title":"Astarte AppEngine API - Architecture overview","doc":"The REST API is called every time Edgehog needs to retrieve data contained in\nan Astarte interface or when it needs to send data to the Devices. In the first case, Edgehog issues\na `GET` HTTP request to retrieve the data from AppEngine API, which reads the data from the Astarte\ndatabase. When Edgehog needs to send data towards a Device instead, it sends a `POST` HTTP to\nAppEngine API, which takes care of delivering data via MQTT to the device.","ref":"overview.html#astarte-appengine-api"},{"type":"extras","title":"Astarte Triggers - Architecture overview","doc":"Astarte Triggers are used to update the online state of the device. Each time a Device connects or\ndisconnects from Astarte, Astarte Trigger Engine sends an HTTP `POST` request to the Edgehog\nbackend, which in turn updates the Device online status in its own database.","ref":"overview.html#astarte-triggers"},{"type":"extras","title":"Deploying with Kubernetes","doc":"<!---\n  Copyright 2021-2023 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Deploying with Kubernetes\n\nEdgehog was designed as a Kubernetes native application, this guide will show how to deploy an\nEdgehog instance in a Kubernetes cluster.\n\n*Note: currently Edgehog requires some manual initialization operations to be performed in the\nElixir interactive shell and is not completely automated. All required operations are detailed\nbelow in the guide.*","ref":"deploying_with_kubernetes.html"},{"type":"extras","title":"Requirements - Deploying with Kubernetes","doc":"- A Kubernetes cluster\n- `kubectl` correctly configured to target the aforementioned cluster\n- An Ingress Controller deployed in the cluster (the guide contains examples for the NGINX Ingress\n  Controller)\n- An Astarte instance, with an existing realm and its private key\n- A PostgreSQL v13+ database\n- S3-compatible storage with its credentials\n- The `jq` utility installed in the system\n- (Optional) A Google Geolocation API Key\n- (Optional) A Google Geocoding API Key\n- (Optional) An ipbase.com API Key\n\nThe guide does not cover in detail how Edgehog is exposed to the internet, since administrators are\nfree to use their favorite Ingress Controller to achieve that. An example Ingress using the NGINX\nIngress Controller is provided, but advanced operations (e.g. certificate management) are out of the\nscope of this guide.\n\nThe guide assumes everything is deployed to the `edgehog` namespace in the Kubernetes cluster, but\nEdgehog can be deployed in any namespace adjusting the `yaml` files and the commands accordingly.\n\nAll fields that have to be customized will be indicated ` `.","ref":"deploying_with_kubernetes.html#requirements"},{"type":"extras","title":"Deploying Edgehog - Deploying with Kubernetes","doc":"This part of the guide will detail all the operations to deploy Edgehog into an existing Kubernetes\ncluster.","ref":"deploying_with_kubernetes.html#deploying-edgehog"},{"type":"extras","title":"Namespace - Deploying with Kubernetes","doc":"First of all, the `edgehog` namespace has to be created\n\n```bash\n$ kubectl create namespace edgehog\n```","ref":"deploying_with_kubernetes.html#namespace"},{"type":"extras","title":"Installing NGINX Ingress Controller and cert-manager (example) - Deploying with Kubernetes","doc":"At this point you should install an Ingress Controller in your cluster. As an example, we will show\nthe procedure to install the NGINX Ingress Controller and cert-manager (to manager SSL certificates)\nusing `helm`. To do so, use these commands\n\n```bash\n$ helm repo add jetstack https://charts.jetstack.io\n$ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\n$ helm repo update\n$ helm install cert-manager jetstack/cert-manager \\\n  --create-namespace --namespace cert-manager --set installCRDs=true\n$ helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \\\n  --create-namespace --namespace ingress-nginx\n```\n\nAfter some minutes, you can retrieve the Load Balancer IP with\n\n```bash\n$ kubectl get svc -n ingress-nginx\n```\n\nin the `EXTERNAL-IP` column.\n\nNote that NGINX is only one of the possible Ingress Controllers, instructions for other Ingress\nControllers are outside the scope of this guide.","ref":"deploying_with_kubernetes.html#installing-nginx-ingress-controller-and-cert-manager-example"},{"type":"extras","title":"Creating DNS entries - Deploying with Kubernetes","doc":"Once you have the Load Balancer IP (obtained in the [previous\nstep](#installing-nginx-ingress-controller-and-cert-manager-example)), head to your DNS provider and\npoint three domains (one for the backend, one for the frontend, and one for the [Device Forwarder](https://github.com/edgehog-device-manager/edgehog_device_forwarder)) to that IP address.\n\nSave the three hosts (e.g. `api.edgehog.example.com`, `edgehog.example.com`, and `forwarder.edgehog.example.com`) since they're going to be needed for the following steps.","ref":"deploying_with_kubernetes.html#creating-dns-entries"},{"type":"extras","title":"Secrets - Deploying with Kubernetes","doc":"A series of secrets containing various credentials have to be created.\n\n#### Database connection\n\nThis command creates the secret containing the details for the database connection:\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-db-connection \\\n  --from-literal=\"database= \" \\\n  --from-literal=\"username= \" \\\n  --from-literal=\"password= \"\n```\n\nValues to be replaced\n- `DATABASE-NAME`: the name of the PostgreSQL database.\n- `DATABASE-USER`: the username to access the database.\n- `DATABASE-PASSWORD`: the password to access the database.\n\n#### Secret key base\n\nThis command creates the secret key base used by Phoenix for the backend:\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-secret-key-base \\\n  --from-literal=\"secret-key-base=$(openssl rand -base64 48)\"\n```\n\nAnother secret key base can be generated for the device forwarder:\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-device-forwarder-secret-key-base \\\n  --from-literal=\"secret-key-base=$(openssl rand -base64 48)\"\n```\n\n#### S3 Credentials (Google Cloud)\n\nTo create an S3-compatbile bucket on Google Cloud to be used with Edgehog, the following steps have\nto be performed:\n\n- [Create a service\n  account](https://cloud.google.com/iam/docs/creating-managing-service-accounts#creating) in your\n  project.\n\n- [Create JSON\ncredentials](https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating) for\nthe service account and rewrite them as a single line JSON:\n\n```bash\n$ gcloud iam service-accounts keys create service_account_credentials.json \\\n  --iam-account= \n$ cat service_account_credentials.json | jq -c > s3_credentials.json\n```\n\n- [Create a Cloud Storage Bucket](https://cloud.google.com/storage/docs/creating-buckets) on GCP\n   * Choose a multiregion in the preferred zones (e.g. Europe)\n   * Remove public access prevention\n   * Choose a fine-grained Access Control, instead of a uniform one\n\n- After making sure of having the right project selected for the `gcloud` CLI, assign the\n`objectAdmin` permission to the service account for the newly created bucket:\n\n```bash\n$ gsutil iam ch serviceAccount: :objectAdmin gs:// \n```\n\n- Create a secret containing the service account credentials\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-s3-credentials \\\n  --from-file=\"gcp-credentials=s3_credentials.json\"\n```\n\nValues to be replaced\n- `SERVICE-ACCOUNT-EMAIL`: the email associated with the service account.\n- `BUCKET-NAME`: the bucket name for the S3 storage.\n\n#### S3 Credentials (Generic)\n\nConsult the documentation of your cloud provider for more details about obtaining an access key ID\nand a secret access key for your S3-compatible storage.\n\nThis command creates the secret containing the S3 credentials:\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-s3-credentials \\\n  --from-literal=\"access-key-id= \" \\\n  --from-literal=\"secret-access-key= \"\n```\n\nValues to be replaced\n- `ACCESS-KEY-ID`: the access key ID for your S3 storage.\n- `SECRET-ACCESS-KEY`: the secret access key for your S3 storage.\n\n#### Google Geolocation API Key (optional)\n\nActivate the Geolocation API for your project in GCP and\n[create an API key](https://developers.google.com/maps/documentation/geolocation/get-api-key) to be\nused with Google Geolocation.\n\nAfter that, create the secret containing the API key with:\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-google-geolocation-credentials \\\n  --from-literal=\"api-key= \" \\\n```\n\nValues to be replaced\n- `API-KEY`: the Google Geolocation API Key obtained from GCP.\n\n#### Google Geocoding API Key (optional)\n\nActivate the Geocoding API for your project in GCP and\n[create an API key](https://developers.google.com/maps/documentation/geocoding/get-api-key) to be\nused with Google Geocoding.\n\nAfter that, create the secret containing the API key with:\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-google-geocoding-credentials \\\n  --from-literal=\"api-key= \"\n```\n\nValues to be replaced\n- `API-KEY`: the Google Geocoding API Key obtained from GCP.\n\n#### ipbase.com API Key (optional)\n\nRegister an account at [ipbase.com](https://ipbase.com/) to obtain an API key.\n\nAfter that, create the secret containing the API key with:\n\n```bash\n$ kubectl create secret generic -n edgehog edgehog-ipbase-credentials \\\n  --from-literal=\"api-key= \"\n```\n\nValues to be replaced\n- `API-KEY`: the API Key obtained from ipbase.com.","ref":"deploying_with_kubernetes.html#secrets"},{"type":"extras","title":"Deployments - Deploying with Kubernetes","doc":"After secrets are deployed, the deployments can be applied to the cluster.\n\n#### Backend\n\nTo deploy the backend, copy the following `yaml` snippet in `backend-deployment.yaml`, fill the\nmissing values (detailed below) and execute\n\n```bash\n$ kubectl apply -f backend-deployment.yaml\n```\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: edgehog-backend\n  name: edgehog-backend\n  namespace: edgehog\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: edgehog-backend\n  template:\n    metadata:\n      labels:\n        app: edgehog-backend\n    spec:\n      containers:\n      - env:\n        - name: RELEASE_NAME\n          value: edgehog\n        - name: PORT\n          value: \"4000\"\n        - name: URL_HOST\n          value:  \n        - name: DATABASE_HOSTNAME\n          value:  \n        - name: DATABASE_NAME\n          valueFrom:\n            secretKeyRef:\n              key: database\n              name: edgehog-db-connection\n        - name: DATABASE_USERNAME\n          valueFrom:\n            secretKeyRef:\n              key: username\n              name: edgehog-db-connection\n        - name: DATABASE_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              key: password\n              name: edgehog-db-connection\n        - name: SECRET_KEY_BASE\n          valueFrom:\n            secretKeyRef:\n              key: secret-key-base\n              name: edgehog-secret-key-base\n        - name: MAX_UPLOAD_SIZE_BYTES\n          value: \" \"\n\n        # Uncomment this env if you have installed an optional ipbase.com API Key in the secrets\n        #\n        #- name: IPBASE_API_KEY\n        #  valueFrom:\n        #    secretKeyRef:\n        #      key: api-key\n        #      name: edgehog-ipbase-credentials\n\n        # Uncomment this env if you have installed an optional Google Geolocation API Key in the\n        # secrets\n        #\n        #- name: GOOGLE_GEOLOCATION_API_KEY\n        #  valueFrom:\n        #    secretKeyRef:\n        #      key: api-key\n        #      name: edgehog-google-geolocation-credentials\n\n        # Uncomment these envs if you have installed an optional Google Geocoding API Key in\n        # the secrets\n        #- name: GOOGLE_GEOCODING_API_KEY\n        #  valueFrom:\n        #    secretKeyRef:\n        #      key: api-key\n        #      name: edgehog-google-geocoding-credentials\n\n        - name: S3_GCP_CREDENTIALS\n          valueFrom:\n            secretKeyRef:\n              key: gcp-credentials\n              name: edgehog-s3-credentials\n\n        # If you're using another S3 provider which is not Google Cloud, uncomment these envs and\n        # delete the previous env\n        #\n        #- name: S3_ACCESS_KEY_ID\n        # valueFrom:\n        #   secretKeyRef:\n        #     key: access-key-id\n        #     name: edgehog-s3-credentials\n        #- name: S3_SECRET_ACCESS_KEY\n        # valueFrom:\n        #   secretKeyRef:\n        #     key: secret-access-key\n        #     name: edgehog-s3-credentials\n\n        - name: S3_SCHEME\n          value:  \n        - name: S3_HOST\n          value:  \n        - name: S3_PORT\n          value: \" \"\n        - name: S3_BUCKET\n          value:  \n        - name: S3_ASSET_HOST\n          value:  \n        - name: S3_REGION\n          value:  \n        - name: EDGEHOG_FORWARDER_HOSTNAME\n          value:  \n        - name: EDGEHOG_FORWARDER_PORT\n          value:  \n        - name: EDGEHOG_FORWARDER_SECURE_SESSIONS\n          value:  \n        image: edgehogdevicemanager/edgehog-backend:0.9.1\n        imagePullPolicy: Always\n        name: edgehog-backend\n        ports:\n        - containerPort: 4000\n          name: http\n          protocol: TCP\n```\n\nValues to be replaced\n- `BACKEND-HOST`: the host of the Edgehog backend (see the [Creating DNS\n  entries](#creating-dns-entries) section).\n- `DATABASE-HOSTNAME`: the hostname of the PostgreSQL database.\n- `MAX-UPLOAD-SIZE-BYTES`: the maximum dimension for uploads, particularly relevant for OTA updates.\n  If omitted, it defaults to 4 Gigabytes.\n- `S3-SCHEME`: the scheme (`http` or `https`) for the S3 storage.\n- `S3-HOST`: the host for the S3 storage.\n- `S3-PORT`: the port for the S3 storage. This has to be put in double quotes to force it to be\n  interpreted as a string.\n- `S3-BUCKET`: the bucket name for the S3 storage.\n- `S3-ASSET-HOST`: the asset host for the S3 storage, e.g. `storage.googleapis.com/ ` for\n  GCP or ` .s3.amazonaws.com` for AWS.\n- `S3-REGION`: the region where the S3 storage resides.\n- `EDGEHOG-FORWARDER-HOSTNAME`: the host for the instance of [Edgehog Device Forwarder](https://github.com/edgehog-device-manager/edgehog_device_forwarder). It should only contain the hostname without the `http://` or `https://` scheme.\n- `EDGEHOG-FORWARDER-PORT`: the port for the instance of [Edgehog Device Forwarder](https://github.com/edgehog-device-manager/edgehog_device_forwarder). It defaults to `443`.\n- `EDGEHOG-FORWARDER-SECURE-SESSIONS`: either `true` or `false`, indicates whether devices use TLS to connect to the [Edgehog Device Forwarder](https://github.com/edgehog-device-manager/edgehog_device_forwarder). It defaults to `true`.\n\nThe optional env variable in the `yaml` also have to be uncommented where relevant (see comments\nabove the commented blocks for more information).\n\n#### Frontend\n\nTo deploy the frontend, copy the following `yaml` snippet in `frontend-deployment.yaml`, fill the\nmissing values (detailed below) and execute\n\n```bash\n$ kubectl apply -f frontend-deployment.yaml\n```\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: edgehog-frontend\n  name: edgehog-frontend\n  namespace: edgehog\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: edgehog-frontend\n  template:\n    metadata:\n      labels:\n        app: edgehog-frontend\n    spec:\n      containers:\n      - env:\n        - name: BACKEND_URL\n          value:  \n        image: edgehogdevicemanager/edgehog-frontend:0.9.1\n        imagePullPolicy: Always\n        name: edgehog-frontend\n        ports:\n        - containerPort: 80\n          name: httpout\n          protocol: TCP\n```\n\nValues to be replaced\n- `BACKEND-URL`: the API base URL of the Edgehog backend (see the [Creating DNS\n  entries](#creating-dns-entries) section). This should be, e.g., `https:// `.\n\n#### Device Forwarder\n\nTo deploy the device forwarder, copy the following `yaml` snippet in `device-forwarder-deployment.yaml`, fill the\nmissing values (detailed below) and execute\n\n```bash\n$ kubectl apply -f device-forwarder-deployment.yaml\n```\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: edgehog-device-forwarder\n  name: edgehog-device-forwarder\n  namespace: edgehog\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: edgehog-device-forwarder\n  template:\n    metadata:\n      labels:\n        app: edgehog-device-forwarder\n    spec:\n      containers:\n      - env:\n        - name: RELEASE_NAME\n          value: edgehog-device-forwarder\n        - name: PORT\n          value: \"4000\"\n        - name: PHX_HOST\n          value:  \n        - name: SECRET_KEY_BASE\n          valueFrom:\n            secretKeyRef:\n              key: secret-key-base\n              name: edgehog-device-forwarder-secret-key-base\n        image: edgehogdevicemanager/edgehog-device-forwarder:0.1.0\n        imagePullPolicy: Always\n        name: edgehog-device-forwarder\n        ports:\n        - containerPort: 4000\n          name: http\n          protocol: TCP\n```\n\nValues to be replaced\n- `DEVICE-FORWARDER-HOST`: the host of the Edgehog Device Forwarder (see the [Creating DNS entries](#creating-dns-entries) section).","ref":"deploying_with_kubernetes.html#deployments"},{"type":"extras","title":"Services - Deploying with Kubernetes","doc":"#### Backend\n\nTo deploy the backend service, copy the following `yaml` snippet in `backend-service.yaml` and\nexecute\n\n```bash\n$ kubectl apply -f backend-service.yaml\n```\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: edgehog-backend\n  name: edgehog-backend\n  namespace: edgehog\nspec:\n  ports:\n  - port: 4000\n    protocol: TCP\n    targetPort: 4000\n  selector:\n    app: edgehog-backend\n```\n\n#### Frontend\n\nTo deploy the frontend service, copy the following `yaml` snippet in `frontend-service.yaml` and\nexecute \n\n```bash\n$ kubectl apply -f frontend-service.yaml\n```\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: edgehog-frontend\n  name: edgehog-frontend\n  namespace: edgehog\nspec:\n  ports:\n  - port: 80\n    protocol: TCP\n    targetPort: 80\n  selector:\n    app: edgehog-frontend\n```\n\n#### Device Forwarder\n\nTo deploy the device forwarder service, copy the following `yaml` snippet in `device-forwarder-service.yaml` and\nexecute\n\n```bash\n$ kubectl apply -f device-forwarder-service.yaml\n```\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: edgehog-device-forwarder\n  name: edgehog-device-forwarder\n  namespace: edgehog\nspec:\n  ports:\n  - port: 4000\n    protocol: TCP\n    targetPort: 4000\n  selector:\n    app: edgehog-device-forwarder\n```","ref":"deploying_with_kubernetes.html#services"},{"type":"extras","title":"Exposing Edgehog to the Internet - Deploying with Kubernetes","doc":"#### SSL Certificates\n\nThis is an example certificates configuration for Edgehog. This is provided as a starting point and\nit uses `certmanager` to obtain LetsEncrypt SSL certificates. All advanced topics (advanced\ncertificate management, self-provided certificates) are not discussed here and are outside the scope\nof this guide.\n\nFirst of all, create a `ClusterIssuer` by copying the following `yaml` snippet in\n`cluster-issuer.yaml` and executing\n\n```bash\n$ kubectl apply -f cluster-issuer.yaml\n```\n\n```yaml\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: letsencrypt\nspec:\n  acme:\n    server: https://acme-v02.api.letsencrypt.org/directory\n    email:  \n    privateKeySecretRef:\n      name: letsencrypt\n    solvers:\n    - http01:\n        ingress:\n          class: nginx\n```\n\nValues to be replaced\n- `EMAIL-ADDRESS`: a valid email address that will be used for the ACME account for LetsEncrypt.\n\nAfter that, create a certificate for your frontend and backend hosts, copying the following `yaml`\nsnippet in `certificate.yaml` and executing\n\n```bash\n$ kubectl apply -f certificate.yaml\n```\n\n```yaml\napiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: tls-secret\n  namespace: edgehog\nspec:\n  secretName: tls-secret\n  dnsNames:\n  -  \n  -  \n  -  \n  issuerRef:\n    group: cert-manager.io\n    kind: ClusterIssuer\n    name: letsencrypt\n```\n\nValues to be replaced\n- `FRONTEND-HOST`: the frontend host.\n- `BACKEND-HOST`: the backend host.\n- `DEVICE-FORWARDER-HOST`: the device forwarder host.\n\nNote that this step must be performed after DNS for the frontend and backend hosts are correctly\npropagated (see [Creating DNS Entries](#creating-dns-entries)).\n\n#### Ingress\n\nThis is an example Ingress configuration for Edgehog. This is provided as a starting point and it\nuses the NGINX Ingress Controller. All advanced topics (e.g. certificate management) are not discussed here\nand are outside the scope of this guide.\n\nCopy this `yaml` snippet to `ingress.yaml` and execute\n\n```bash\n$ kubectl apply -f ingress.yaml\n```\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    cert-manager.io/cluster-issuer: letsencrypt\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/proxy-body-size:  \n    nginx.ingress.kubernetes.io/proxy-read-timeout: \"120\"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: \"120\"\n  name: edgehog-ingress\n  namespace: edgehog\nspec:\n  rules:\n  - host:  \n    http:\n      paths:\n      - backend:\n          service:\n            name: edgehog-frontend\n            port:\n              number: 80\n        path: /\n        pathType: Prefix\n  - host:  \n    http:\n      paths:\n      - backend:\n          service:\n            name: edgehog-backend\n            port:\n              number: 4000\n        path: /\n        pathType: Prefix\n  - host:  \n    http:\n      paths:\n      - backend:\n          service:\n            name: edgehog-device-forwarder\n            port:\n              number: 4000\n        path: /\n        pathType: Prefix\n  tls:\n  - hosts:\n    -  \n    -  \n    -  \n    secretName: tls-secret\n```\n\nValues to be replaced\n- `FRONTEND-HOST`: the frontend host.\n- `BACKEND-HOST`: the backend host.\n- `DEVICE-FORWARDER-HOST`: the device forwarder host.\n- `MAX-UPLOAD-SIZE`: the maximum upload size that you defined in the [Edgehog backend\n  deployment](https://edgehog-device-manager.github.io/docs/0.9/deploying_with_kubernetes.html#deployments).\n  Note that NGINX accepts also size suffixes, so you can put, e.g., `4G` for 4 gigabytes. Also note\n  that, differently from the value in the Deployment, this is required because NGINX default is 1\n  megabyte.\n\nNote that we are setting `proxy-read-timeout` and `proxy-send-timeout` to 120 seconds.\nThis value represents the timeout after which inactive connections are terminated.\nThis configuration has implications on the inactive sessions of the Device Forwarder: the forwarder has its own default timeout of 1 minute for terminating inactive WebSocket connections, and setting a lower timeout here would conflict with the forwarder's internal processes. For this reason, we leave that responsibility to the forwarder by setting a slightly higher timeout here, such as 2 minutes.\nWhen changing the value, one should also evaluate the implications on connections to Edgehog's frontend and backend. In addition, higher values may lead to higher risk of DoS attacks.","ref":"deploying_with_kubernetes.html#exposing-edgehog-to-the-internet"},{"type":"extras","title":"Edgehog Initialization - Deploying with Kubernetes","doc":"These are some manual operation that have to be performed to initialize the Edgehog instance. In the\nfuture these operation will be automated and/or will be performed using a dedicated API.","ref":"deploying_with_kubernetes.html#edgehog-initialization"},{"type":"extras","title":"Creating a keypair - Deploying with Kubernetes","doc":"A keypair is needed to emit and validate tokens to access your tenant. You can generate an EC\nkeypair with the following OpenSSL commands\n\n```bash\n$ openssl ecparam -name prime256v1 -genkey -noout > private_key.pem\n$ openssl ec -in private_key.pem -pubout > public_key.pem\n```\n\nAfter those commands are executed, you will have two files: `private_key.pem` and `public_key.pem`.\nThe content of `public_key.pem` will be needed in the next steps, while `private_key.pem` will be\nused to emit Edgehog tokens. Make sure to store the private key somewhere safe.","ref":"deploying_with_kubernetes.html#creating-a-keypair"},{"type":"extras","title":"Connecting to `iex` - Deploying with Kubernetes","doc":"Connect to the `iex` interactive shell of the Edgehog backend using\n\n```bash\n$ kubectl exec -it deploy/edgehog-backend -n edgehog -- /app/bin/edgehog remote\n```\n\nAll the following commands have to be executed inside that shell, in a single session (since some\ncommands will reuse the result of previous commands)","ref":"deploying_with_kubernetes.html#connecting-to-iex"},{"type":"extras","title":"Creating the tenant - Deploying with Kubernetes","doc":"The following commands will create a database entry representing the tenant, with its associated\nAstarte cluster and Realm.\n\n```elixir\niex> alias Edgehog.Provisioning\niex> tenant_name = \" \"\niex> tenant_slug = \" \"\niex> tenant_public_key = \"\"\"\n \n\"\"\"\niex> base_api_url = \" \"\niex> realm_name = \" \"\niex> realm_private_key = \"\"\"\n \n\"\"\"\niex> {:ok, tenant} = Provisioning.provision_tenant(\n  %{\n    name: tenant_name,\n    slug: tenant_slug,\n    public_key: tenant_public_key,\n    astarte_config: %{\n      base_api_url: base_api_url,\n      realm_name: realm_name,\n      realm_private_key: realm_private_key\n    }\n  })\n```\n\nValues to be replaced\n- `TENANT-NAME`: the name of the new tenant.\n- `TENANT-SLUG`: the slug of the tenant, must contain only lowercase letters and hyphens.\n- `TENANT-PUBLIC-KEY`: the content of `public_key.pem` created in the [previous\n  step](#creating-a-keypair). Open a multiline string with `\"\"\"`, press Enter, paste the content of\n  the file in the `iex` shell and then close the multiline string with `\"\"\"` on a new line.\n- `ASTARTE-BASE-API-URL`: the base API url of the Astarte instance (e.g.\n  https://api.astarte.example.com).\n- `ASTARTE-REALM-NAME`: the name of the Astarte realm you're using.\n- `ASTARTE-REALM-PRIVATE-KEY`: the content of you realm's private key. Open a multiline string with\n  `\"\"\"`, press Enter, paste the content of the file in the `iex` shell and then close the multiline\n  string with `\"\"\"` on a new line.","ref":"deploying_with_kubernetes.html#creating-the-tenant"},{"type":"extras","title":"Accessing Edgehog - Deploying with Kubernetes","doc":"At this point your Edgehog instance is ready to use. The last step is generating a token to access\nyour Edgehog frontend instance. You can do so using the `gen-edgehog-jwt` tool contained in the\n`tools` directory of the [Edgehog\nrepo](https://github.com/edgehog-device-manager/edgehog/tree/main/tools).\n\n```bash\n$ pip3 install pyjwt\n$ ./gen-edgehog-jwt -t tenant -k  \n```\n\nValues to be replaced\n- `PATH-TO-TENANT-PRIVATE-KEY`: path to the `private_key.pem` file created in the [previous\n  step](#creating-a-keypair).\n\nNote that the token expires after 24 hours by default. If you want to have a token with a different\nexpiry time, you can pass `-e  ` to the `gen-edgehog-jwt` command.\n\nAfter that, you can open your frontend URL in your browser and insert your tenant slug and token to\nlog into your Edgehog instance, and use to the [user guide](#intro_user) to discover all Edgehog\nfeatures.","ref":"deploying_with_kubernetes.html#accessing-edgehog"},{"type":"extras","title":"Interacting with Edgehog","doc":"<!---\n  Copyright 2021,2022 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Interacting with Edgehog\n\nEdgehog's interaction is logically divided amongst two main entities: devices and users.\n\n_Devices_ are the bottom end, and represent the IoT fleet. They can access\n[Astarte](https://github.com/astarte-platform/astarte) and exchange data via Astarte Interfaces\nwhich, in turn, also define on a very granular level which kind of data they can exchange. Data\nexposed by devices are relayed to Edgehog via Astarte Triggers.\n\n_Users_ are actual users, applications or anything else which needs to interact with Edgehog.","ref":"interacting_with_edgehog.html"},{"type":"extras","title":"User-side Tools - Interacting with Edgehog","doc":"To interact with Edgehog, several options are available:\n\n- Edgehog's dashboard interface: it provides a built-in UI that can be used for managing Devices,\n  Hardware Types, and System Models. It is meant to be a graphical, user-friendly tool to manage\n  those entities.\n- [Edgehog's Admin REST APIs](admin-rest-api/): they are meant as a machine-friendly way to\n  perform provisioning operations and manage Edgehog's tenants.\n- [Edgehog's Tenant GraphQL APIs](tenant-graphql-api/): they are meant to perform operations on a\n  specific tenant's entities and for integrating 3rd party applications.","ref":"interacting_with_edgehog.html#user-side-tools"},{"type":"extras","title":"Publishing Device data - Interacting with Edgehog","doc":"Devices can publish any kind of data to Astarte via Astarte Interfaces. However, some standard\ninterfaces are already supported by Edgehog in order to provide useful functionalities, such as\ndevice geolocation.\n\nHence, data that devices send via\n[Edgehog's Astarte Interfaces](https://github.com/edgehog-device-manager/edgehog-astarte-interfaces/)\nare automatically understood, collected and reported by Edgehog.","ref":"interacting_with_edgehog.html#publishing-device-data"},{"type":"extras","title":"Publishing info about the System - Interacting with Edgehog","doc":"Each Device is supposed to notify Astarte, e.g. on each connection, about its System.\n\nTo do so, the Device can use the [io.edgehog.devicemanager.SystemInfo](astarte_interfaces.html)\nAstarte Interface to specify:\n\n- the Serial Number: a code that uniquely identifies the System\n- the Part Number: a code that uniquely identifies the System Model\n\nWhen exposing the Part Number, Edgehog can associate the Device to the correct System Model by\nmatching the Device's Part Number with the ones of the registered System Model.","ref":"interacting_with_edgehog.html#publishing-info-about-the-system"},{"type":"extras","title":"Publishing info about the hardware - Interacting with Edgehog","doc":"Each Device can notify Astarte about the general capabilities of the Device. These info are\nhardware-related and are usually not intended to change over time.\n\nA Device can expose this set of data via the\n[io.edgehog.devicemanager.HardwareInfo](astarte_interfaces.html) Astarte Interface.","ref":"interacting_with_edgehog.html#publishing-info-about-the-hardware"},{"type":"extras","title":"Publishing info about the Device status - Interacting with Edgehog","doc":"To expose info about its current status or measured data, some additional Astarte Interfaces are\nalready defined for Edgehog. Their adoption is optional but recommended.\n\n- [io.edgehog.devicemanager.SystemStatus](astarte_interfaces.html): reports the current OS status.\n- [io.edgehog.devicemanager.StorageUsage](astarte_interfaces.html): reports the capacity and usage\n  of the storage units.\n- [io.edgehog.devicemanager.BatteryStatus](astarte_interfaces.html): reports the current status of\n  the battery slots.\n- [io.edgehog.devicemanager.Geolocation](astarte_interfaces.html): reports the current position\n  computed by the GPS sensors of the device.\n- [io.edgehog.devicemanager.WiFiScanResults](astarte_interfaces.html): reports the list of nearby\n  Access Points that the Device found while scanning for WiFi signals.","ref":"interacting_with_edgehog.html#publishing-info-about-the-device-status"},{"type":"extras","title":"Astarte Interfaces","doc":"# Astarte Interfaces","ref":"astarte_interfaces.html"},{"type":"extras","title":"io.edgehog.devicemanager.BaseImage v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-baseimage-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/fingerprint` with `string` type. OS bundle release identification code\n- `/name` with `string` type. Name of the bundle\n- `/version` with `string` type. Version of the bundle\n- `/buildId` with `string` type. Human readable build identifier. Examples are `[date][time]` or `[date]-[time]-[git-commit]`\n\n\n### `/fingerprint`\n\nOS bundle release identification code\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/name`\n\nName of the bundle\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/version`\n\nVersion of the bundle\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/buildId`\n\nHuman readable build identifier. Examples are `[date][time]` or `[date]-[time]-[git-commit]`\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.BatteryStatus v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-batterystatus-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{battery_slot}/levelPercentage` with `double` type. Battery level estimated percentage [0.0%-100.0%]\n- `/%{battery_slot}/levelAbsoluteError` with `double` type. Battery level measurement absolute error [0.0-100.0]\n- `/%{battery_slot}/status` with `string` type. Battery status string, any of: Charging, Discharging, Idle, EitherIdleOrCharging, Failure, Removed, Unknown\n\n\n### `/%{battery_slot}/levelPercentage`\n\nBattery level estimated percentage [0.0%-100.0%]\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `battery_slot` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{battery_slot}/levelAbsoluteError`\n\nBattery level measurement absolute error [0.0-100.0]\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `battery_slot` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{battery_slot}/status`\n\nBattery status string, any of: Charging, Discharging, Idle, EitherIdleOrCharging, Failure, Removed, Unknown\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `battery_slot` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.CellularConnectionProperties v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-cellularconnectionproperties-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{id}/apn` with `string` type. Operator apn address.\n- `/%{id}/imei` with `string` type. The modem IMEI code of the device.\n- `/%{id}/imsi` with `string` type. The SIM IMSI code of the device.\n\n\n### `/%{id}/apn`\n\nOperator apn address.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.\n\n### `/%{id}/imei`\n\nThe modem IMEI code of the device.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.\n\n### `/%{id}/imsi`\n\nThe SIM IMSI code of the device.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.CellularConnectionStatus v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-cellularconnectionstatus-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{id}/carrier` with `string` type. Connectivity carrier operator name.\n- `/%{id}/cellId` with `longinteger` type. The Cell ID in hexadecimal format, either 16 bit for 2G or 28 bit for 3G or 4G.\n- `/%{id}/mobileCountryCode` with `integer` type. The mobile country code (MCC) for the device's home network. Valid range: 0999.\n- `/%{id}/mobileNetworkCode` with `integer` type. The Mobile Network Code for the device's home network. This is the MNC for GSM, WCDMA, LTE and NR. CDMA uses the System ID (SID). Valid range for MNC: 0999. Valid range for SID: 032767.\n- `/%{id}/localAreaCode` with `integer` type. Two byte location area code in hexadecimal format.\n- `/%{id}/registrationStatus` with `string` type. GSM/LTE registration status. Possible values: [NotRegistered, Registered, SearchingOperator, RegistrationDenied, Unknown, RegisteredRoaming]\n- `/%{id}/rssi` with `double` type. Signal strenght of the device in dBm.\n- `/%{id}/technology` with `string` type. Access Technology. Possible values [GSM, GSMCompact, UTRAN, GSMwEGPRS, UTRANwHSDPA, UTRANwHSUPA, UTRANwHSDPAandHSUPA, EUTRAN]\n\n\n### `/%{id}/carrier`\n\nConnectivity carrier operator name.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/cellId`\n\nThe Cell ID in hexadecimal format, either 16 bit for 2G or 28 bit for 3G or 4G.\n\n\n\nThis endpoint accepts values of type `longinteger`: a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.).\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/mobileCountryCode`\n\nThe mobile country code (MCC) for the device's home network. Valid range: 0999.\n\n\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/mobileNetworkCode`\n\nThe Mobile Network Code for the device's home network. This is the MNC for GSM, WCDMA, LTE and NR. CDMA uses the System ID (SID). Valid range for MNC: 0999. Valid range for SID: 032767.\n\n\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/localAreaCode`\n\nTwo byte location area code in hexadecimal format.\n\n\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/registrationStatus`\n\nGSM/LTE registration status. Possible values: [NotRegistered, Registered, SearchingOperator, RegistrationDenied, Unknown, RegisteredRoaming]\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/rssi`\n\nSignal strenght of the device in dBm.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/technology`\n\nAccess Technology. Possible values [GSM, GSMCompact, UTRAN, GSMwEGPRS, UTRANwHSDPA, UTRANwHSUPA, UTRANwHSDPAandHSUPA, EUTRAN]\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.Commands v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-commands-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `server`, meaning that it is the server which initiates the data flow.\nThanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `individual` aggregation.\nEach mapping is treated as an independent value and is managed individually.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/request` with `string` type. Command request. Possible values  ['Reboot']\n\n\n### `/request`\n\nCommand request. Possible values  ['Reboot']\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when it has been received exactly once by the recipient.\nData is discarded if the transport is temporarily uncapable of delivering it.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.ForwarderSessionRequest v0.1 - Astarte Interfaces","doc":"Configuration to open a session with the Edgehog Forwarder from a device to a certain host.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-forwardersessionrequest-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `server`, meaning that it is the server which initiates the data flow.\nThanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/request/session_token` with `string` type. The session token thanks to which the device can authenticates itself through Edgehog.\n- `/request/port` with `integer` type. The host port the device must connect to.\n- `/request/host` with `string` type. The IP address or host name the device must connect to.\n- `/request/secure` with `boolean` type. Indicates whether the connection should use TLS, i.e. 'ws' or 'wss' scheme.\n\n\n### `/request/session_token`\n\nThe session token thanks to which the device can authenticates itself through Edgehog.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/request/port`\n\nThe host port the device must connect to.\n\n\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/request/host`\n\nThe IP address or host name the device must connect to.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/request/secure`\n\nIndicates whether the connection should use TLS, i.e. 'ws' or 'wss' scheme.\n\n\n\nThis endpoint accepts values of type `boolean`: either true or false, adhering to JSON boolean type.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.ForwarderSessionState v0.1 - Astarte Interfaces","doc":"Information provided by the device about the status of a forwarder session.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-forwardersessionstate-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{session_token}/status` with `string` type. Indicates if the device is connecting, or connected to a forwarder session.\n\n\n### `/%{session_token}/status`\n\nIndicates if the device is connecting, or connected to a forwarder session.\n\nAn enum with the following possible values: Connecting | Connected.\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `session_token` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.Geolocation v0.1 - Astarte Interfaces","doc":"Generic Geolocation sampled data.\n\nGeolocation allows geolocation sensors to stream location data, such as GPS data. Values availability depends on what sensors are present on devices and what measurement systems are in use. The id represents a unique identifier for an individual sensor.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-geolocation-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{id}/latitude` with `double` type. Sampled latitude value.\n- `/%{id}/longitude` with `double` type. Sampled longitude value.\n- `/%{id}/altitude` with `double` type. Sampled altitude value.\n- `/%{id}/accuracy` with `double` type. Sampled accuracy of the latitude and longitude properties.\n- `/%{id}/altitudeAccuracy` with `double` type. Sampled accuracy of the altitude property.\n- `/%{id}/heading` with `double` type. Sampled value representing the direction towards which the device is facing.\n- `/%{id}/speed` with `double` type. Sampled value representing the velocity of the device.\n\n\n### `/%{id}/latitude`\n\nSampled latitude value.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/longitude`\n\nSampled longitude value.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/altitude`\n\nSampled altitude value.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/accuracy`\n\nSampled accuracy of the latitude and longitude properties.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/altitudeAccuracy`\n\nSampled accuracy of the altitude property.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/heading`\n\nSampled value representing the direction towards which the device is facing.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{id}/speed`\n\nSampled value representing the velocity of the device.\n\n\n\nThis endpoint accepts values of type `double`: a double-precision floating-point number as specified by binary64, by the IEEE 754 standard.\n\nThe endpoint is parametric and `id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.HardwareInfo v0.1 - Astarte Interfaces","doc":"General hardware capabilities","ref":"astarte_interfaces.html#io-edgehog-devicemanager-hardwareinfo-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/cpu/architecture` with `string` type. CPU Architecture \n- `/cpu/model` with `string` type. CPU Model Code\n- `/cpu/modelName` with `string` type. CPU Model Display Name\n- `/cpu/vendor` with `string` type. CPU Vendor\n- `/mem/totalBytes` with `longinteger` type. Total RAM quantity (Bytes)\n\n\n### `/cpu/architecture`\n\nCPU Architecture \n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/cpu/model`\n\nCPU Model Code\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/cpu/modelName`\n\nCPU Model Display Name\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/cpu/vendor`\n\nCPU Vendor\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/mem/totalBytes`\n\nTotal RAM quantity (Bytes)\n\n\n\nThis endpoint accepts values of type `longinteger`: a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.).\n\nThe value of the property cannot be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.LedBehavior v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-ledbehavior-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `server`, meaning that it is the server which initiates the data flow.\nThanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `individual` aggregation.\nEach mapping is treated as an independent value and is managed individually.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{led_id}/behavior` with `string` type. Enum describing the behavior of the given led. Possible values: [Blink60Seconds | DoubleBlink60Seconds | SlowBlink60Seconds]\n\n\n### `/%{led_id}/behavior`\n\nEnum describing the behavior of the given led. Possible values: [Blink60Seconds | DoubleBlink60Seconds | SlowBlink60Seconds]\n\nBlink60Seconds: Blinking\nDoubleBlink60Seconds: Double blinking\nSlowBlink60Seconds: Slow blinking\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `led_id` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when it has been received exactly once by the recipient.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.NetworkInterfaceProperties v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-networkinterfaceproperties-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{iface_name}/macAddress` with `string` type. Normalized physical address. Example value is \"00:aa:bb:cc:dd:ee\" (always lower case)\n- `/%{iface_name}/technologyType` with `string` type. Connection technology. Possible values: [Ethernet, Bluetooth, Cellular, WiFi]\n\n\n### `/%{iface_name}/macAddress`\n\nNormalized physical address. Example value is \"00:aa:bb:cc:dd:ee\" (always lower case)\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `iface_name` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.\n\n### `/%{iface_name}/technologyType`\n\nConnection technology. Possible values: [Ethernet, Bluetooth, Cellular, WiFi]\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint is parametric and `iface_name` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.OSInfo v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-osinfo-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/osName` with `string` type. Name of the Operating System\n- `/osVersion` with `string` type. Version of the Operating System\n\n\n### `/osName`\n\nName of the Operating System\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/osVersion`\n\nVersion of the Operating System\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.OTAEvent v0.1 - Astarte Interfaces","doc":"OTA Events sampled data.\n\nAllows to stream OTA Events data, including OTA Update status, its progress, code and internal message.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-otaevent-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/event/requestUUID` with `string` type. OTA Request identifier.\n- `/event/status` with `string` type. OTA Update status.\n- `/event/statusProgress` with `integer` type. Current OTA Update status progress percentage [0%-100%].\n- `/event/statusCode` with `string` type. Status code expands OTA Update status with additional information.\n- `/event/message` with `string` type. Contains internal message for status code or empty string otherwise.\n\n\n### `/event/requestUUID`\n\nOTA Request identifier.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when it has been received exactly once by the recipient.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/event/status`\n\nOTA Update status.\n\nValue is one of the following strings:\n\n - `Acknowledged`: the device received an OTA Request.\n - `Downloading`: an update is in the process of downloading.\n - `Deploying`: an update is in the process of deploying.\n - `Deployed`: an update deployed on the device.\n - `Rebooting`: the device is in the process of rebooting.\n - `Success`: an update succeeded. This is a final status of OTA Update.\n - `Error`: an error happened during the update. Also this status can be used to notify about handled errors.\n - `Failure`: an update failed. This is a final status of OTA Update.\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when it has been received exactly once by the recipient.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/event/statusProgress`\n\nCurrent OTA Update status progress percentage [0%-100%].\n\nEvery OTA Update status has own progress that starts from 0 and ends at 100, for example (pairs of `\"status, progress\"`): `\"Downloading, 0\"`, `\"Downloading, 50\"`, `\"Downloading, 100\"`, `\"Deploying, 10\"`, etc.\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when it has been received exactly once by the recipient.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/event/statusCode`\n\nStatus code expands OTA Update status with additional information.\n\nSome common status codes are:\n\n  - `InvalidRequest`: an update request contains incorrect data.\n - `UpdateAlreadyInProgress`: another update is currently in progress.\n  - `NetworkError`: a network error happened during the update.\n  - `IOError`: a filesystem error happened during the update.\n  - `InternalError`: an internal error happened during the update.\n  - `InvalidBaseImage`: an update failed to apply due to an invalid base image.\n  - `SystemRollback`: a system rollback has occurred.\n  - `Canceled`: an update was canceled.\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when it has been received exactly once by the recipient.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/event/message`\n\nContains internal message for status code or empty string otherwise.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when it has been received exactly once by the recipient.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.OTARequest v1.0 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-otarequest-v1-0"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `server`, meaning that it is the server which initiates the data flow.\nThanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/request/operation` with `string` type. OTA Request operation\n- `/request/url` with `string` type. File URL\n- `/request/uuid` with `string` type. Request identifier\n\n\n### `/request/operation`\n\nOTA Request operation\n\nValue is one of the following strings:\n\n - `Update`: push an OTA update operation.\n - `Cancel`: cancel an OTA update if it can still be cancelled.\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/request/url`\n\nFile URL\n\nIf the operation is Update, this will contain the URL that can be used to download the Update.\n If the operation is Cancel, this will be an empty string.\n Note that the URL will be valid only until the OTA update is active (i.e. it didn't reach a Failure or Success state), after that it's possible that the URL can become invalid.\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.\n\n### `/request/uuid`\n\nRequest identifier\n\nA UUID that uniquely identifies the OTA request. It must be stored when receiving an Update operation so that it can be matched against in case a Cancel operation is received.\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 31556952 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.RuntimeInfo v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-runtimeinfo-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/name` with `string` type. Name of the Edgehog runtime. Example value: `edgehog-esp32-device`\n- `/url` with `string` type. URL that uniquely identifies the Edgehog Edgehog runtime implementation. Example value: `https://github.com/edgehog-device-manager/edgehog-esp32-device`.\n- `/version` with `string` type. Version of the Edgehog runtime. Example value: `0.5`\n- `/environment` with `string` type. Environment of the Edgehog runtime. Example value: `esp-idf VERSION`, `Rust 1.58` or `Java 8`\n\n\n### `/name`\n\nName of the Edgehog runtime. Example value: `edgehog-esp32-device`\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/url`\n\nURL that uniquely identifies the Edgehog Edgehog runtime implementation. Example value: `https://github.com/edgehog-device-manager/edgehog-esp32-device`.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/version`\n\nVersion of the Edgehog runtime. Example value: `0.5`\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/environment`\n\nEnvironment of the Edgehog runtime. Example value: `esp-idf VERSION`, `Rust 1.58` or `Java 8`\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.StorageUsage v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-storageusage-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/%{label}/totalBytes` with `longinteger` type. Total storage size in bytes\n- `/%{label}/freeBytes` with `longinteger` type. Available storage bytes\n\n\n### `/%{label}/totalBytes`\n\nTotal storage size in bytes\n\n\n\nThis endpoint accepts values of type `longinteger`: a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.).\n\nThe endpoint is parametric and `label` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/%{label}/freeBytes`\n\nAvailable storage bytes\n\n\n\nThis endpoint accepts values of type `longinteger`: a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.).\n\nThe endpoint is parametric and `label` can be replaced with any valid string to send data on specialized paths.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.SystemInfo v0.1 - Astarte Interfaces","doc":"Information about the system","ref":"astarte_interfaces.html#io-edgehog-devicemanager-systeminfo-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/serialNumber` with `string` type. The serial number of the system\n- `/partNumber` with `string` type. The part number of the system\n\n\n### `/serialNumber`\n\nThe serial number of the system\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.\n\n### `/partNumber`\n\nThe part number of the system\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe value of the property cannot be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.SystemStatus v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-systemstatus-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/systemStatus/availMemoryBytes` with `longinteger` type. Available memory (Bytes)\n- `/systemStatus/bootId` with `string` type. UUID representing the Boot Id\n- `/systemStatus/taskCount` with `integer` type. Number of running tasks or processes\n- `/systemStatus/uptimeMillis` with `longinteger` type. Get time in milliseconds since boot\n\n\n### `/systemStatus/availMemoryBytes`\n\nAvailable memory (Bytes)\n\n\n\nThis endpoint accepts values of type `longinteger`: a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.).\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/systemStatus/bootId`\n\nUUID representing the Boot Id\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/systemStatus/taskCount`\n\nNumber of running tasks or processes\n\n\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/systemStatus/uptimeMillis`\n\nGet time in milliseconds since boot\n\n\n\nThis endpoint accepts values of type `longinteger`: a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.).\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.WiFiScanResults v0.2 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-wifiscanresults-v0-2"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `datastream` and is owned by the `device`, meaning that it is the device which initiates the data flow.\nThanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization.\n\nData gets sent with an `object` aggregation.\nAstarte expects the owner to send all of the interface's mappings at the same time, packed in a single message.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/ap/channel` with `integer` type. The channel over which the client is communicating with the access point.\n- `/ap/connected` with `boolean` type. Identifies if the device is connected to this Access Point\n- `/ap/essid` with `string` type. Extended Service Set Identification of the current AP, empty string if the AP is hidden.\n- `/ap/macAddress` with `string` type. Lower case mac address string formatted like `de:ad:be:ff:11:22`.\n- `/ap/rssi` with `integer` type. The current signal strength measured in dBm.\n\n\n### `/ap/channel`\n\nThe channel over which the client is communicating with the access point.\n\nThe channel represents one of the ranges into which the reference frequency is divided and it's identified by an integer number in the range 1 - 165, depending on the frequency itself and the region.\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/ap/connected`\n\nIdentifies if the device is connected to this Access Point\n\n\n\nThis endpoint accepts values of type `boolean`: either true or false, adhering to JSON boolean type.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/ap/essid`\n\nExtended Service Set Identification of the current AP, empty string if the AP is hidden.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/ap/macAddress`\n\nLower case mac address string formatted like `de:ad:be:ff:11:22`.\n\n\n\nThis endpoint accepts values of type `string`: an UTF-8 string, at most 65536 bytes long.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.\n\n### `/ap/rssi`\n\nThe current signal strength measured in dBm.\n\n\n\nThis endpoint accepts values of type `integer`: a signed 32 bit integer.\n\nThe endpoint has a specific configuration for how data is stored, transferred and indexed.\nAstarte expects a valid timestamp to be attached each time data is produced.\nData is considered delivered when the transport successfully sends the data regardless of the outcome.\nData is discarded if the transport is temporarily uncapable of delivering it.\nDelivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"io.edgehog.devicemanager.config.Telemetry v0.1 - Astarte Interfaces","doc":"","ref":"astarte_interfaces.html#io-edgehog-devicemanager-config-telemetry-v0-1"},{"type":"extras","title":"About - Astarte Interfaces","doc":"This interface is of type `properties` and is owned by the `server`, meaning that it is the server which initiates the data flow.\nThanks to this type of interface, the server can set a persistent, stateful, synchronized state with no concept of history or timestamping.","ref":"astarte_interfaces.html#about"},{"type":"extras","title":"Mappings - Astarte Interfaces","doc":"The interface has the following mappings:\n\n- `/request/%{interface_name}/enable` with `boolean` type. Enable/Disable telemetry update. Unset returns to the previous state configured in the device.\n- `/request/%{interface_name}/periodSeconds` with `longinteger` type. Set interval of period seconds between the end of the previous update and the start of the next one. Unset returns to the previous state configured in the device.\n\n\n### `/request/%{interface_name}/enable`\n\nEnable/Disable telemetry update. Unset returns to the previous state configured in the device.\n\n\n\nThis endpoint accepts values of type `boolean`: either true or false, adhering to JSON boolean type.\n\nThe endpoint is parametric and `interface_name` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.\n\n### `/request/%{interface_name}/periodSeconds`\n\nSet interval of period seconds between the end of the previous update and the start of the next one. Unset returns to the previous state configured in the device.\n\n\n\nThis endpoint accepts values of type `longinteger`: a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.).\n\nThe endpoint is parametric and `interface_name` can be replaced with any valid string to send data on specialized paths.\n\nThe value of the property can be unset.","ref":"astarte_interfaces.html#mappings"},{"type":"extras","title":"Edgehog in 5 minutes","doc":"<!---\n  Copyright 2023-2024 SECO Mind Srl\n\n  SPDX-License-Identifier: Apache-2.0\n-->\n\n# Edgehog in 5 minutes","ref":"edgehog_in_5_minutes.html"},{"type":"extras","title":"Prerequisites - Edgehog in 5 minutes","doc":"Edgehog interacts with devices through [Astarte](https://github.com/astarte-platform/astarte).\nWhile it's possible to run an instance of Edgehog without the local instance of Astarte for development purposes,\nit's recommended to setup Astarte locally for full functionality.","ref":"edgehog_in_5_minutes.html#prerequisites"},{"type":"extras","title":"Setup your local Astarte instance - Edgehog in 5 minutes","doc":"The easiest way to setup local Astarte instance is to follow the [Astarte in 5 minutes](https://docs.astarte-platform.org/astarte/latest/010-astarte_in_5_minutes.html) guide, up until the creation of a `test` realm.\n\nTo make sure your astarte instance is working and up to date, try running this command:\n\n```sh\n$ curl api.astarte.localhost &> /dev/null && echo 'Connected!' || echo 'Astarte is unreachable'\n```\n\nIf you get \"Astarte is unreachable\", make sure your running astarte version is >= v1.1.0","ref":"edgehog_in_5_minutes.html#setup-your-local-astarte-instance"},{"type":"extras","title":"Run a local Edgehog instance - Edgehog in 5 minutes","doc":"To setup edgehog, you must first clone a copy of edgehog locally\n\n```sh\n$ git clone https://github.com/edgehog-device-manager/edgehog && cd edgehog\n```\n\n> If you just want to try out Edgehog without interacting with the device, run it without the Astarte instance:\n>\n> ```sh\n> $ docker compose \\\n> $   -f docker-compose.yml \\\n> $   -f docker-compose.without-astarte.yml \\\n> $   up -d\n> ```\n>\n> Then jump to the [populate the database section](#populate-the-database-and-log-in-to-edgehog).\n\nRun Edgehog along with a local instance of Astarte with\n\n```sh\n$ docker compose up -d\n```\n\nTry navigating to `http://edgehog.localhost`: you should be presented with a login screen!","ref":"edgehog_in_5_minutes.html#run-a-local-edgehog-instance"},{"type":"extras","title":"Setup the environment - Edgehog in 5 minutes","doc":"Open the `.env` file in your favorite text editor.\nHere you can edit docker's variables to match your current environment.\nRight now we're only interested in the `SEEDS_*` variables, which are used to populate the database.\n\n| Variable                        | Description                                                                                           |\n| ------------------------------- | ----------------------------------------------------------------------------------------------------- |\n| `SEEDS_REALM`                   | The name of your astarte realm. It should match what you've created in your astarte setup             |\n| `SEEDS_REALM_PRIVATE_KEY_FILE`  | The location of the realm's private key file (`test_private.pem` from the Astarte in 5 minutes guide) |\n| `SEEDS_TENANT_PRIVATE_KEY_FILE` | The location of the [tenant's private key file](#generate-a-key-pair-for-the-tenant)                  |\n| `SEEDS_ASTARTE_BASE_API_URL`    | The endpoint for Astarte API.                                                                         |\n\nIf for whatever reason you don't want to edit the `.env` file, you can also export\nenvironment variables of the same name.\n\n`SEEDS_REALM` and `SEEDS_ASTARTE_BASE_API_URL` should already be set for you, so only edit those if\nneeded.","ref":"edgehog_in_5_minutes.html#setup-the-environment"},{"type":"extras","title":"Generate a key pair for the tenant - Edgehog in 5 minutes","doc":"Although it is possible to use a default key, it is recommended to have your own key pair for the\ntenant.\n\nYou should already have [`astartectl`](https://github.com/astarte-platform/astartectl#installation)\ninstalled from the Astarte in 5 minutes guide.\n\n```sh\n$ astartectl utils gen-keypair acme\n```\n\n**Remember to update** the `.env` file with the `acme_private.pem` location!","ref":"edgehog_in_5_minutes.html#generate-a-key-pair-for-the-tenant"},{"type":"extras","title":"Populate the database and log in to Edgehog - Edgehog in 5 minutes","doc":"Run this command to populate the database\n\n```sh\n$ docker compose exec edgehog-backend bin/edgehog eval Edgehog.Release.seed\n```\n\nThis will create the tenant `acme-inc` and add a sample device to it.\n\n> _\"I had the wrong variables set, and now I can't run the seed again. What now?\"_\n> If this happens, the easiest solution is to just recreate the edgehog volumes:\n>\n> ```sh\n> $ docker compose down -v && docker compose up -d\n> ```\n\nNice! Now we have our tenant but we can't access to it yet, we need a token.\nLuckily Edgehog includes a scripts to generate one!\n\nFirst you'll need to make sure to have python version 3 installed.\n\n```sh\n$ python3 --version\nPython 3.x.y\n```\n\n> While not mandatory, it is advised to use a python virtual environment to make sure your\n> globally installed python packages don't mess with this script's dependencies and vice versa.\n> Doing this is pretty straightforward, but you may need to install the `python3-venv` package if\n> you are using a Debian/Ubuntu-based system.\n>\n> ```sh\n> $ python3 -m venv pyenv\n> $ source pyenv/bin/activate\n> ```\n\nThen, navigate to the `tools/` subdirectory and install the required dependencies\n\n```sh\n$ cd tools && pip install -r requirements.txt\n```\n\nNow you can generate the login token with\n\n```sh\n$ ./gen-edgehog-jwt -t tenant -k ../acme_private.pem\n```\n\n> If in the previous section you had decided not to use a custom key, use this command instead\n>\n> ```sh\n> $ ./gen-edgehog-jwt -t tenant -k ../backend/priv/repo/seeds/keys/tenant_private.pem\n> ```\n\nYou can finally navigate to `http://edgehog.localhost` in your browser and login to the\n`acme-inc` tenant using your newly generated token.","ref":"edgehog_in_5_minutes.html#populate-the-database-and-log-in-to-edgehog"},{"type":"extras","title":"Test Astarte connection - Edgehog in 5 minutes","doc":"Astarte connectivity may not work right away, as edgehog has not yet reconciled\nits interfaces and triggers with astarte. Without waiting, we can force it to execute\nthe reconciler using:\n\n```sh\n$ docker compose exec edgehog-backend bin/edgehog rpc \"Edgehog.Tenants.list_tenants |> Enum.each(&Edgehog.Tenants.reconcile_tenant/1)\"\n```\n\nIf you now connect a device to astarte and open or reload the edgehog web page,\nyou should see the new device in the appropriate section.\n\n> You can use [stream-qt5-test](https://docs.astarte-platform.org/astarte/latest/010-astarte_in_5_minutes.html#stream-data).\n> If you do so the device won't have any edgehog interface, but it will still show up as connected.","ref":"edgehog_in_5_minutes.html#test-astarte-connection"},{"type":"extras","title":"Cleaning up - Edgehog in 5 minutes","doc":"As with astarte, you can clean your environment by running\n\n```sh\n$ docker compose down\n```\n\nto stop all the running edgehog containers.","ref":"edgehog_in_5_minutes.html#cleaning-up"}],"content_type":"text/markdown","producer":{"name":"ex_doc","version":[48,46,51,52,46,50]}}